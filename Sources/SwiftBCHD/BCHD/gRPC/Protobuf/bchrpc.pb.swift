// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: bchrpc.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Pb_SlpTokenType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case versionNotSet // = 0
  case v1Fungible // = 1
  case v1Nft1Child // = 65
  case v1Nft1Group // = 129
  case UNRECOGNIZED(Int)

  init() {
    self = .versionNotSet
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .versionNotSet
    case 1: self = .v1Fungible
    case 65: self = .v1Nft1Child
    case 129: self = .v1Nft1Group
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .versionNotSet: return 0
    case .v1Fungible: return 1
    case .v1Nft1Child: return 65
    case .v1Nft1Group: return 129
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Pb_SlpTokenType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Pb_SlpTokenType] = [
    .versionNotSet,
    .v1Fungible,
    .v1Nft1Child,
    .v1Nft1Group,
  ]
}

#endif  // swift(>=4.2)

/// SlpAction is used to allow clients to identify the type of slp transaction from this single field.
///
/// NOTE: All enum types except for "NON_SLP" may be annotated with one or more BurnFlags.
enum Pb_SlpAction: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case nonSlp // = 0
  case nonSlpBurn // = 1
  case slpParseError // = 2
  case slpUnsupportedVersion // = 3
  case slpV1Genesis // = 4
  case slpV1Mint // = 5
  case slpV1Send // = 6
  case slpV1Nft1GroupGenesis // = 7
  case slpV1Nft1GroupMint // = 8
  case slpV1Nft1GroupSend // = 9
  case slpV1Nft1UniqueChildGenesis // = 10
  case slpV1Nft1UniqueChildSend // = 11
  case UNRECOGNIZED(Int)

  init() {
    self = .nonSlp
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .nonSlp
    case 1: self = .nonSlpBurn
    case 2: self = .slpParseError
    case 3: self = .slpUnsupportedVersion
    case 4: self = .slpV1Genesis
    case 5: self = .slpV1Mint
    case 6: self = .slpV1Send
    case 7: self = .slpV1Nft1GroupGenesis
    case 8: self = .slpV1Nft1GroupMint
    case 9: self = .slpV1Nft1GroupSend
    case 10: self = .slpV1Nft1UniqueChildGenesis
    case 11: self = .slpV1Nft1UniqueChildSend
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .nonSlp: return 0
    case .nonSlpBurn: return 1
    case .slpParseError: return 2
    case .slpUnsupportedVersion: return 3
    case .slpV1Genesis: return 4
    case .slpV1Mint: return 5
    case .slpV1Send: return 6
    case .slpV1Nft1GroupGenesis: return 7
    case .slpV1Nft1GroupMint: return 8
    case .slpV1Nft1GroupSend: return 9
    case .slpV1Nft1UniqueChildGenesis: return 10
    case .slpV1Nft1UniqueChildSend: return 11
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Pb_SlpAction: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Pb_SlpAction] = [
    .nonSlp,
    .nonSlpBurn,
    .slpParseError,
    .slpUnsupportedVersion,
    .slpV1Genesis,
    .slpV1Mint,
    .slpV1Send,
    .slpV1Nft1GroupGenesis,
    .slpV1Nft1GroupMint,
    .slpV1Nft1GroupSend,
    .slpV1Nft1UniqueChildGenesis,
    .slpV1Nft1UniqueChildSend,
  ]
}

#endif  // swift(>=4.2)

struct Pb_GetMempoolInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pb_GetMempoolInfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The count of transactions in the mempool
  var size: UInt32 = 0

  /// The size in bytes of all transactions in the mempool
  var bytes: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pb_GetMempoolRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// When `full_transactions` is true, full transaction data is provided
  /// instead of just transaction hashes. Default is false.
  var fullTransactions: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pb_GetMempoolResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of unconfirmed transactions.
  var transactionData: [Pb_GetMempoolResponse.TransactionData] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct TransactionData {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Either one of the two following is provided, depending on the request.
    var txidsOrTxs: Pb_GetMempoolResponse.TransactionData.OneOf_TxidsOrTxs? = nil

    /// The transaction hash, little-endian.
    var transactionHash: Data {
      get {
        if case .transactionHash(let v)? = txidsOrTxs {return v}
        return Data()
      }
      set {txidsOrTxs = .transactionHash(newValue)}
    }

    /// The transaction data.
    var transaction: Pb_Transaction {
      get {
        if case .transaction(let v)? = txidsOrTxs {return v}
        return Pb_Transaction()
      }
      set {txidsOrTxs = .transaction(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Either one of the two following is provided, depending on the request.
    enum OneOf_TxidsOrTxs: Equatable {
      /// The transaction hash, little-endian.
      case transactionHash(Data)
      /// The transaction data.
      case transaction(Pb_Transaction)

    #if !swift(>=4.1)
      static func ==(lhs: Pb_GetMempoolResponse.TransactionData.OneOf_TxidsOrTxs, rhs: Pb_GetMempoolResponse.TransactionData.OneOf_TxidsOrTxs) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.transactionHash, .transactionHash): return {
          guard case .transactionHash(let l) = lhs, case .transactionHash(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.transaction, .transaction): return {
          guard case .transaction(let l) = lhs, case .transaction(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    init() {}
  }

  init() {}
}

struct Pb_GetBlockchainInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pb_GetBlockchainInfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Which network the node is operating on.
  var bitcoinNet: Pb_GetBlockchainInfoResponse.BitcoinNet = .mainnet

  /// The current number of blocks on the longest chain.
  var bestHeight: Int32 = 0

  /// The hash of the best (tip) block in the most-work fully-validated chain, little-endian.
  var bestBlockHash: Data = Data()

  /// Threshold for adding new blocks.
  var difficulty: Double = 0

  /// Median time of the last 11 blocks.
  var medianTime: Int64 = 0

  /// When `tx_index` is true, the node has full transaction index enabled.
  var txIndex: Bool = false

  /// When `addr_index` is true, the node has address index enabled and may
  /// be used with call related by address.
  var addrIndex: Bool = false

  /// When `slp_index` is true, the node has the slp index enabled and may
  /// be used with slp related rpc methods and also causes slp metadata to be added
  /// in some of the existing rpc methods.
  var slpIndex: Bool = false

  /// When `slp_graphsearch` is true, the node is able to handle calls to slp graph search
  var slpGraphsearch: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Bitcoin network types
  enum BitcoinNet: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Live public network with monetary value.
    case mainnet // = 0

    /// An isolated environment for automated testing.
    case regtest // = 1

    /// A public environment where monetary value is agreed to be zero,
    /// and some checks for transaction conformity are disabled.
    case testnet3 // = 2

    /// Private testnets for large scale simulations (or stress testing),
    /// where a specified list of nodes is used, rather than node discovery.
    case simnet // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .mainnet
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .mainnet
      case 1: self = .regtest
      case 2: self = .testnet3
      case 3: self = .simnet
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .mainnet: return 0
      case .regtest: return 1
      case .testnet3: return 2
      case .simnet: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Pb_GetBlockchainInfoResponse.BitcoinNet: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Pb_GetBlockchainInfoResponse.BitcoinNet] = [
    .mainnet,
    .regtest,
    .testnet3,
    .simnet,
  ]
}

#endif  // swift(>=4.2)

struct Pb_GetBlockInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hashOrHeight: Pb_GetBlockInfoRequest.OneOf_HashOrHeight? = nil

  /// The block hash as a byte array or base64 encoded string, little-endian.
  var hash: Data {
    get {
      if case .hash(let v)? = hashOrHeight {return v}
      return Data()
    }
    set {hashOrHeight = .hash(newValue)}
  }

  /// The block number.
  var height: Int32 {
    get {
      if case .height(let v)? = hashOrHeight {return v}
      return 0
    }
    set {hashOrHeight = .height(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_HashOrHeight: Equatable {
    /// The block hash as a byte array or base64 encoded string, little-endian.
    case hash(Data)
    /// The block number.
    case height(Int32)

  #if !swift(>=4.1)
    static func ==(lhs: Pb_GetBlockInfoRequest.OneOf_HashOrHeight, rhs: Pb_GetBlockInfoRequest.OneOf_HashOrHeight) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.hash, .hash): return {
        guard case .hash(let l) = lhs, case .hash(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.height, .height): return {
        guard case .height(let l) = lhs, case .height(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Pb_GetBlockInfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Marshaled block header data, as well as metadata.
  var info: Pb_BlockInfo {
    get {return _info ?? Pb_BlockInfo()}
    set {_info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  var hasInfo: Bool {return self._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  mutating func clearInfo() {self._info = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _info: Pb_BlockInfo? = nil
}

struct Pb_GetBlockRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hashOrHeight: Pb_GetBlockRequest.OneOf_HashOrHeight? = nil

  /// The block hash as a byte array or base64 encoded string, little-endian.
  var hash: Data {
    get {
      if case .hash(let v)? = hashOrHeight {return v}
      return Data()
    }
    set {hashOrHeight = .hash(newValue)}
  }

  /// The block number.
  var height: Int32 {
    get {
      if case .height(let v)? = hashOrHeight {return v}
      return 0
    }
    set {hashOrHeight = .height(newValue)}
  }

  /// When `full_transactions` is true, full transactions are returned
  /// instead of just hashes. Default is false.
  var fullTransactions: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_HashOrHeight: Equatable {
    /// The block hash as a byte array or base64 encoded string, little-endian.
    case hash(Data)
    /// The block number.
    case height(Int32)

  #if !swift(>=4.1)
    static func ==(lhs: Pb_GetBlockRequest.OneOf_HashOrHeight, rhs: Pb_GetBlockRequest.OneOf_HashOrHeight) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.hash, .hash): return {
        guard case .hash(let l) = lhs, case .hash(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.height, .height): return {
        guard case .height(let l) = lhs, case .height(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Pb_GetBlockResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A marshaled block.
  var block: Pb_Block {
    get {return _block ?? Pb_Block()}
    set {_block = newValue}
  }
  /// Returns true if `block` has been explicitly set.
  var hasBlock: Bool {return self._block != nil}
  /// Clears the value of `block`. Subsequent reads from it will return its default value.
  mutating func clearBlock() {self._block = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _block: Pb_Block? = nil
}

struct Pb_GetRawBlockRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hashOrHeight: Pb_GetRawBlockRequest.OneOf_HashOrHeight? = nil

  /// The block hash as a byte array or base64 encoded string, little-endian.
  var hash: Data {
    get {
      if case .hash(let v)? = hashOrHeight {return v}
      return Data()
    }
    set {hashOrHeight = .hash(newValue)}
  }

  /// The block number.
  var height: Int32 {
    get {
      if case .height(let v)? = hashOrHeight {return v}
      return 0
    }
    set {hashOrHeight = .height(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_HashOrHeight: Equatable {
    /// The block hash as a byte array or base64 encoded string, little-endian.
    case hash(Data)
    /// The block number.
    case height(Int32)

  #if !swift(>=4.1)
    static func ==(lhs: Pb_GetRawBlockRequest.OneOf_HashOrHeight, rhs: Pb_GetRawBlockRequest.OneOf_HashOrHeight) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.hash, .hash): return {
        guard case .hash(let l) = lhs, case .hash(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.height, .height): return {
        guard case .height(let l) = lhs, case .height(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Pb_GetRawBlockResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Raw block data (with header) serialized according the the bitcoin block protocol.
  var block: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pb_GetBlockFilterRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hashOrHeight: Pb_GetBlockFilterRequest.OneOf_HashOrHeight? = nil

  /// The block hash as a byte array or base64 encoded string, little-endian.
  var hash: Data {
    get {
      if case .hash(let v)? = hashOrHeight {return v}
      return Data()
    }
    set {hashOrHeight = .hash(newValue)}
  }

  /// The block number.
  var height: Int32 {
    get {
      if case .height(let v)? = hashOrHeight {return v}
      return 0
    }
    set {hashOrHeight = .height(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_HashOrHeight: Equatable {
    /// The block hash as a byte array or base64 encoded string, little-endian.
    case hash(Data)
    /// The block number.
    case height(Int32)

  #if !swift(>=4.1)
    static func ==(lhs: Pb_GetBlockFilterRequest.OneOf_HashOrHeight, rhs: Pb_GetBlockFilterRequest.OneOf_HashOrHeight) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.hash, .hash): return {
        guard case .hash(let l) = lhs, case .hash(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.height, .height): return {
        guard case .height(let l) = lhs, case .height(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Pb_GetBlockFilterResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A compact filter matching input outpoints and public key scripts contained
  /// in a block (encoded according to BIP158).
  var filter: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request headers using a list of known block hashes.
struct Pb_GetHeadersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of block hashes known to the client (most recent first) which
  /// is exponentially sparser toward the genesis block (0), little-endian.
  /// Common practice is to include all of the last 10 blocks, and then
  /// 9 blocks for each order of ten thereafter.
  var blockLocatorHashes: [Data] = []

  /// hash of the latest desired block header, little-endian; only blocks
  /// occurring before the stop will be returned.
  var stopHash: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pb_GetHeadersResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of block headers.
  var headers: [Pb_BlockInfo] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Get a transaction from a transaction hash.
struct Pb_GetTransactionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A transaction hash, little-endian.
  var hash: Data = Data()

  var includeTokenMetadata: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pb_GetTransactionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A marshaled transaction.
  var transaction: Pb_Transaction {
    get {return _transaction ?? Pb_Transaction()}
    set {_transaction = newValue}
  }
  /// Returns true if `transaction` has been explicitly set.
  var hasTransaction: Bool {return self._transaction != nil}
  /// Clears the value of `transaction`. Subsequent reads from it will return its default value.
  mutating func clearTransaction() {self._transaction = nil}

  var tokenMetadata: Pb_SlpTokenMetadata {
    get {return _tokenMetadata ?? Pb_SlpTokenMetadata()}
    set {_tokenMetadata = newValue}
  }
  /// Returns true if `tokenMetadata` has been explicitly set.
  var hasTokenMetadata: Bool {return self._tokenMetadata != nil}
  /// Clears the value of `tokenMetadata`. Subsequent reads from it will return its default value.
  mutating func clearTokenMetadata() {self._tokenMetadata = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _transaction: Pb_Transaction? = nil
  fileprivate var _tokenMetadata: Pb_SlpTokenMetadata? = nil
}

/// Get an encoded transaction from a transaction hash.
struct Pb_GetRawTransactionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A transaction hash, little-endian.
  var hash: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pb_GetRawTransactionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Raw transaction in bytes.
  var transaction: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Get marshaled transactions related to a specific address.
///
/// RECOMMENDED:
/// Parameters have been provided to query without creating
///   performance issues on the node or client.
///
/// - The number of transactions to skip and fetch allow for iterating
///       over a large set of transactions, if necessary.
///
/// - A starting block parameter (either `hash` or `height`)
///       may then be used to filter results to those occurring
///       after a certain time.
///
/// This approach will reduce network traffic and response processing
///   for the client, as well as reduce workload on the node.
struct Pb_GetAddressTransactionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The address to query transactions, in lowercase cashaddr format.
  /// The network prefix is optional (i.e. "cashaddress:").
  var address: String = String()

  /// The number of confirmed transactions to skip, starting with the oldest first.
  /// Does not affect results of unconfirmed transactions.
  var nbSkip: UInt32 = 0

  /// Specify the number of transactions to fetch.
  var nbFetch: UInt32 = 0

  var startBlock: Pb_GetAddressTransactionsRequest.OneOf_StartBlock? = nil

  /// Recommended. Only get transactions after (or within) a
  /// starting block identified by hash, little-endian.
  var hash: Data {
    get {
      if case .hash(let v)? = startBlock {return v}
      return Data()
    }
    set {startBlock = .hash(newValue)}
  }

  /// Recommended. Only get transactions after (or within) a
  /// starting block identified by block number.
  var height: Int32 {
    get {
      if case .height(let v)? = startBlock {return v}
      return 0
    }
    set {startBlock = .height(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_StartBlock: Equatable {
    /// Recommended. Only get transactions after (or within) a
    /// starting block identified by hash, little-endian.
    case hash(Data)
    /// Recommended. Only get transactions after (or within) a
    /// starting block identified by block number.
    case height(Int32)

  #if !swift(>=4.1)
    static func ==(lhs: Pb_GetAddressTransactionsRequest.OneOf_StartBlock, rhs: Pb_GetAddressTransactionsRequest.OneOf_StartBlock) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.hash, .hash): return {
        guard case .hash(let l) = lhs, case .hash(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.height, .height): return {
        guard case .height(let l) = lhs, case .height(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Pb_GetAddressTransactionsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Transactions that have been included in a block.
  var confirmedTransactions: [Pb_Transaction] = []

  /// Transactions in mempool which have not been included in a block.
  var unconfirmedTransactions: [Pb_MempoolTransaction] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Get encoded transactions related to a specific address.
///
/// RECOMMENDED:
/// Parameters have been provided to query without creating
///   performance issues on the node or client.
///
/// - The number of transactions to skip and fetch allow for iterating
///       over a large set of transactions, if necessary.
///
/// - A starting block parameter (either `hash` or `height`)
///       may then be used to filter results to those occurring
///       after a certain time.
///
/// This approach will reduce network traffic and response processing
///   for the client, as well as reduce workload on the node.
struct Pb_GetRawAddressTransactionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The address to query transactions, in lowercase cashaddr format.
  /// The network prefix is optional (i.e. "cashaddress:").
  var address: String = String()

  /// The number of confirmed transactions to skip, starting with the oldest first.
  /// Does not affect results of unconfirmed transactions.
  var nbSkip: UInt32 = 0

  /// Specify the number of transactions to fetch.
  var nbFetch: UInt32 = 0

  var startBlock: Pb_GetRawAddressTransactionsRequest.OneOf_StartBlock? = nil

  /// Recommended. Only return transactions after some starting block
  /// identified by hash, little-endian.
  var hash: Data {
    get {
      if case .hash(let v)? = startBlock {return v}
      return Data()
    }
    set {startBlock = .hash(newValue)}
  }

  /// Recommended. Only return transactions after some starting block
  /// identified by block number.
  var height: Int32 {
    get {
      if case .height(let v)? = startBlock {return v}
      return 0
    }
    set {startBlock = .height(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_StartBlock: Equatable {
    /// Recommended. Only return transactions after some starting block
    /// identified by hash, little-endian.
    case hash(Data)
    /// Recommended. Only return transactions after some starting block
    /// identified by block number.
    case height(Int32)

  #if !swift(>=4.1)
    static func ==(lhs: Pb_GetRawAddressTransactionsRequest.OneOf_StartBlock, rhs: Pb_GetRawAddressTransactionsRequest.OneOf_StartBlock) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.hash, .hash): return {
        guard case .hash(let l) = lhs, case .hash(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.height, .height): return {
        guard case .height(let l) = lhs, case .height(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Pb_GetRawAddressTransactionsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Transactions that have been included in a block.
  var confirmedTransactions: [Data] = []

  /// Transactions in mempool which have not been included in a block.
  var unconfirmedTransactions: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pb_GetAddressUnspentOutputsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The address to query transactions, in lowercase cashaddr format.
  /// The network identifier is optional (i.e. "cashaddress:").
  var address: String = String()

  /// When `include_mempool` is true, unconfirmed transactions from mempool
  /// are returned. Default is false.
  var includeMempool: Bool = false

  var includeTokenMetadata: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pb_GetAddressUnspentOutputsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of unspent outputs.
  var outputs: [Pb_UnspentOutput] = []

  var tokenMetadata: [Pb_SlpTokenMetadata] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pb_GetUnspentOutputRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The hash of the transaction, little-endian.
  var hash: Data = Data()

  /// The number of the output, starting from zero.
  var index: UInt32 = 0

  /// When include_mempool is true, unconfirmed transactions from mempool
  /// are returned. Default is false.
  var includeMempool: Bool = false

  var includeTokenMetadata: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pb_GetUnspentOutputResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A reference to the related input.
  var outpoint: Pb_Transaction.Input.Outpoint {
    get {return _storage._outpoint ?? Pb_Transaction.Input.Outpoint()}
    set {_uniqueStorage()._outpoint = newValue}
  }
  /// Returns true if `outpoint` has been explicitly set.
  var hasOutpoint: Bool {return _storage._outpoint != nil}
  /// Clears the value of `outpoint`. Subsequent reads from it will return its default value.
  mutating func clearOutpoint() {_uniqueStorage()._outpoint = nil}

  /// Locking script dictating how funds can be spent in the future
  var pubkeyScript: Data {
    get {return _storage._pubkeyScript}
    set {_uniqueStorage()._pubkeyScript = newValue}
  }

  /// Amount in satoshi.
  var value: Int64 {
    get {return _storage._value}
    set {_uniqueStorage()._value = newValue}
  }

  /// When is_coinbase is true, the transaction was the first in a block,
  /// created by a miner, and used to pay the block reward
  var isCoinbase: Bool {
    get {return _storage._isCoinbase}
    set {_uniqueStorage()._isCoinbase = newValue}
  }

  /// The index number of the block containing the transaction creating the output.
  var blockHeight: Int32 {
    get {return _storage._blockHeight}
    set {_uniqueStorage()._blockHeight = newValue}
  }

  var slpToken: Pb_SlpToken {
    get {return _storage._slpToken ?? Pb_SlpToken()}
    set {_uniqueStorage()._slpToken = newValue}
  }
  /// Returns true if `slpToken` has been explicitly set.
  var hasSlpToken: Bool {return _storage._slpToken != nil}
  /// Clears the value of `slpToken`. Subsequent reads from it will return its default value.
  mutating func clearSlpToken() {_uniqueStorage()._slpToken = nil}

  var tokenMetadata: Pb_SlpTokenMetadata {
    get {return _storage._tokenMetadata ?? Pb_SlpTokenMetadata()}
    set {_uniqueStorage()._tokenMetadata = newValue}
  }
  /// Returns true if `tokenMetadata` has been explicitly set.
  var hasTokenMetadata: Bool {return _storage._tokenMetadata != nil}
  /// Clears the value of `tokenMetadata`. Subsequent reads from it will return its default value.
  mutating func clearTokenMetadata() {_uniqueStorage()._tokenMetadata = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Pb_GetMerkleProofRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A transaction hash, little-endian.
  var transactionHash: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pb_GetMerkleProofResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Block header information for the corresponding transaction
  var block: Pb_BlockInfo {
    get {return _block ?? Pb_BlockInfo()}
    set {_block = newValue}
  }
  /// Returns true if `block` has been explicitly set.
  var hasBlock: Bool {return self._block != nil}
  /// Clears the value of `block`. Subsequent reads from it will return its default value.
  mutating func clearBlock() {self._block = nil}

  /// A list containing the transaction hash, the adjacent leaf transaction hash
  /// and the hashes of the highest nodes in the merkle tree not built with the transaction.
  /// Proof hashes are ordered following transaction order, or left to right on the merkle tree
  var hashes: [Data] = []

  /// Binary representing the location of the matching transaction in the full merkle tree,
  /// starting with the root (`1`) at position/level 0, where `1` corresponds
  /// to a left branch and `01` is a right branch.
  var flags: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _block: Pb_BlockInfo? = nil
}

struct Pb_SubmitTransactionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The encoded transaction.
  var transaction: Data = Data()

  var skipSlpValidityCheck: Bool = false

  var requiredSlpBurns: [Pb_SlpRequiredBurn] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pb_SubmitTransactionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Transaction hash, little-endian.
  var hash: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pb_CheckSlpTransactionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var transaction: Data = Data()

  var requiredSlpBurns: [Pb_SlpRequiredBurn] = []

  /// Using the slp specification as a basis for validity judgement can lead to confusion for new users and
  /// result in accidental token burns.  use_spec_validity_judgement will cause the response's is_valid property
  /// to be returned according to the slp specification.  Therefore, use_spec_validity_judgement is false by
  /// default in order to avoid accidental token burns.  When use_spec_validity_judgement is false we return
  /// invalid in any case which would result in a burned token, unless the burn is explicitly included as an
  /// item in required_slp_burns property.
  ///
  /// When use_spec_validity_judgement is true, there are three cases where the is_valid response property
  /// will be returned as valid, instead of invalid, as per the slp specification.  
  ///   1) inputs > outputs
  ///   2) missing transaction outputs
  ///   3) burned inputs from other tokens
  /// 
  /// required_slp_burns is not used when use_spec_validity_judgement is set to true.
  var useSpecValidityJudgement: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pb_CheckSlpTransactionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var isValid: Bool = false

  var invalidReason: String = String()

  var bestHeight: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request to subscribe or unsubscribe from a stream of transactions.
struct Pb_SubscribeTransactionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Subscribe to a filter. add items to a filter
  var subscribe: Pb_TransactionFilter {
    get {return _subscribe ?? Pb_TransactionFilter()}
    set {_subscribe = newValue}
  }
  /// Returns true if `subscribe` has been explicitly set.
  var hasSubscribe: Bool {return self._subscribe != nil}
  /// Clears the value of `subscribe`. Subsequent reads from it will return its default value.
  mutating func clearSubscribe() {self._subscribe = nil}

  /// Unsubscribe to a filter, remove items from a filter
  var unsubscribe: Pb_TransactionFilter {
    get {return _unsubscribe ?? Pb_TransactionFilter()}
    set {_unsubscribe = newValue}
  }
  /// Returns true if `unsubscribe` has been explicitly set.
  var hasUnsubscribe: Bool {return self._unsubscribe != nil}
  /// Clears the value of `unsubscribe`. Subsequent reads from it will return its default value.
  mutating func clearUnsubscribe() {self._unsubscribe = nil}

  /// When include_mempool is true, new unconfirmed transactions from mempool are
  /// included apart from the ones confirmed in a block.
  var includeMempool: Bool = false

  /// When include_in_block is true, transactions are included when they are confirmed.
  /// This notification is sent in addition to any requested mempool notifications.
  var includeInBlock: Bool = false

  /// When serialize_tx is true, transactions are serialized using
  /// bitcoin protocol encoding. Default is false, transaction will be Marshaled
  /// (see `Transaction`, `MempoolTransaction` and `TransactionNotification`)
  var serializeTx: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _subscribe: Pb_TransactionFilter? = nil
  fileprivate var _unsubscribe: Pb_TransactionFilter? = nil
}

/// Options to define data structure to be sent by SubscribeBlock stream:
///
///  - BlockInfo (block metadata): `BlockInfo`
///      - SubscribeBlocksRequest {}
///
///  - Marshaled Block (with transaction hashes): `Block`
///      - SubscribeBlocksRequest {
///            full_block = true
///        }
///  - Marshaled Block (with full transaction data): `Block`
///      - SubscribeBlocksRequest {
///            full_block = true
///            full_transactions = true
///        }
///  - Serialized Block acccording to bitcoin protocol encoding: `bytes`
///      - SubscribeBlocksRequest {
///            serialize_block = true
///        }
struct Pb_SubscribeBlocksRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// When full_block is true, a complete marshaled block is sent. See `Block`.
  /// Default is false, block metadata is sent. See `BlockInfo`.
  var fullBlock: Bool = false

  /// When full_transactions is true, provide full transaction info
  /// for a marshaled block.
  /// Default is false, only the transaction hashes are included for
  /// a marshaled block. See `TransactionData`.
  var fullTransactions: Bool = false

  /// When serialize_block is true, blocks are serialized using bitcoin protocol encoding.
  /// Default is false, block will be Marshaled (see `BlockInfo` and `BlockNotification`)
  var serializeBlock: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pb_GetSlpTokenMetadataRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tokenIds: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pb_GetSlpTokenMetadataResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tokenMetadata: [Pb_SlpTokenMetadata] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pb_GetSlpParsedScriptRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var slpOpreturnScript: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pb_GetSlpParsedScriptResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var parsingError: String = String()

  var tokenID: Data = Data()

  var slpAction: Pb_SlpAction = .nonSlp

  var tokenType: Pb_SlpTokenType = .versionNotSet

  var slpMetadata: Pb_GetSlpParsedScriptResponse.OneOf_SlpMetadata? = nil

  /// NFT1 Group also uses this
  var v1Genesis: Pb_SlpV1GenesisMetadata {
    get {
      if case .v1Genesis(let v)? = slpMetadata {return v}
      return Pb_SlpV1GenesisMetadata()
    }
    set {slpMetadata = .v1Genesis(newValue)}
  }

  /// NFT1 Group also uses this
  var v1Mint: Pb_SlpV1MintMetadata {
    get {
      if case .v1Mint(let v)? = slpMetadata {return v}
      return Pb_SlpV1MintMetadata()
    }
    set {slpMetadata = .v1Mint(newValue)}
  }

  /// NFT1 Group also uses this
  var v1Send: Pb_SlpV1SendMetadata {
    get {
      if case .v1Send(let v)? = slpMetadata {return v}
      return Pb_SlpV1SendMetadata()
    }
    set {slpMetadata = .v1Send(newValue)}
  }

  var v1Nft1ChildGenesis: Pb_SlpV1Nft1ChildGenesisMetadata {
    get {
      if case .v1Nft1ChildGenesis(let v)? = slpMetadata {return v}
      return Pb_SlpV1Nft1ChildGenesisMetadata()
    }
    set {slpMetadata = .v1Nft1ChildGenesis(newValue)}
  }

  var v1Nft1ChildSend: Pb_SlpV1Nft1ChildSendMetadata {
    get {
      if case .v1Nft1ChildSend(let v)? = slpMetadata {return v}
      return Pb_SlpV1Nft1ChildSendMetadata()
    }
    set {slpMetadata = .v1Nft1ChildSend(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_SlpMetadata: Equatable {
    /// NFT1 Group also uses this
    case v1Genesis(Pb_SlpV1GenesisMetadata)
    /// NFT1 Group also uses this
    case v1Mint(Pb_SlpV1MintMetadata)
    /// NFT1 Group also uses this
    case v1Send(Pb_SlpV1SendMetadata)
    case v1Nft1ChildGenesis(Pb_SlpV1Nft1ChildGenesisMetadata)
    case v1Nft1ChildSend(Pb_SlpV1Nft1ChildSendMetadata)

  #if !swift(>=4.1)
    static func ==(lhs: Pb_GetSlpParsedScriptResponse.OneOf_SlpMetadata, rhs: Pb_GetSlpParsedScriptResponse.OneOf_SlpMetadata) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.v1Genesis, .v1Genesis): return {
        guard case .v1Genesis(let l) = lhs, case .v1Genesis(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.v1Mint, .v1Mint): return {
        guard case .v1Mint(let l) = lhs, case .v1Mint(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.v1Send, .v1Send): return {
        guard case .v1Send(let l) = lhs, case .v1Send(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.v1Nft1ChildGenesis, .v1Nft1ChildGenesis): return {
        guard case .v1Nft1ChildGenesis(let l) = lhs, case .v1Nft1ChildGenesis(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.v1Nft1ChildSend, .v1Nft1ChildSend): return {
        guard case .v1Nft1ChildSend(let l) = lhs, case .v1Nft1ChildSend(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Pb_GetSlpTrustedValidationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var queries: [Pb_GetSlpTrustedValidationRequest.Query] = []

  var includeGraphsearchCount: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Query {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var prevOutHash: Data = Data()

    var prevOutVout: UInt32 = 0

    var graphsearchValidHashes: [Data] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct Pb_GetSlpTrustedValidationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var results: [Pb_GetSlpTrustedValidationResponse.ValidityResult] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct ValidityResult {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var prevOutHash: Data = Data()

    var prevOutVout: UInt32 = 0

    var tokenID: Data = Data()

    var slpAction: Pb_SlpAction = .nonSlp

    var tokenType: Pb_SlpTokenType = .versionNotSet

    var validityResultType: Pb_GetSlpTrustedValidationResponse.ValidityResult.OneOf_ValidityResultType? = nil

    var v1TokenAmount: UInt64 {
      get {
        if case .v1TokenAmount(let v)? = validityResultType {return v}
        return 0
      }
      set {validityResultType = .v1TokenAmount(newValue)}
    }

    var v1MintBaton: Bool {
      get {
        if case .v1MintBaton(let v)? = validityResultType {return v}
        return false
      }
      set {validityResultType = .v1MintBaton(newValue)}
    }

    var slpTxnOpreturn: Data = Data()

    var graphsearchTxnCount: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_ValidityResultType: Equatable {
      case v1TokenAmount(UInt64)
      case v1MintBaton(Bool)

    #if !swift(>=4.1)
      static func ==(lhs: Pb_GetSlpTrustedValidationResponse.ValidityResult.OneOf_ValidityResultType, rhs: Pb_GetSlpTrustedValidationResponse.ValidityResult.OneOf_ValidityResultType) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.v1TokenAmount, .v1TokenAmount): return {
          guard case .v1TokenAmount(let l) = lhs, case .v1TokenAmount(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.v1MintBaton, .v1MintBaton): return {
          guard case .v1MintBaton(let l) = lhs, case .v1MintBaton(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    init() {}
  }

  init() {}
}

struct Pb_GetSlpGraphSearchRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hash: Data = Data()

  var validHashes: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pb_GetSlpGraphSearchResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var txdata: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pb_BlockNotification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether the block is connected to the chain.
  var type: Pb_BlockNotification.TypeEnum = .connected

  var block: Pb_BlockNotification.OneOf_Block? = nil

  /// Marshaled block header data, as well as metadata stored by the node.
  var blockInfo: Pb_BlockInfo {
    get {
      if case .blockInfo(let v)? = block {return v}
      return Pb_BlockInfo()
    }
    set {block = .blockInfo(newValue)}
  }

  /// A Block.
  var marshaledBlock: Pb_Block {
    get {
      if case .marshaledBlock(let v)? = block {return v}
      return Pb_Block()
    }
    set {block = .marshaledBlock(newValue)}
  }

  /// Binary block, serialized using bitcoin protocol encoding.
  var serializedBlock: Data {
    get {
      if case .serializedBlock(let v)? = block {return v}
      return Data()
    }
    set {block = .serializedBlock(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Block: Equatable {
    /// Marshaled block header data, as well as metadata stored by the node.
    case blockInfo(Pb_BlockInfo)
    /// A Block.
    case marshaledBlock(Pb_Block)
    /// Binary block, serialized using bitcoin protocol encoding.
    case serializedBlock(Data)

  #if !swift(>=4.1)
    static func ==(lhs: Pb_BlockNotification.OneOf_Block, rhs: Pb_BlockNotification.OneOf_Block) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.blockInfo, .blockInfo): return {
        guard case .blockInfo(let l) = lhs, case .blockInfo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.marshaledBlock, .marshaledBlock): return {
        guard case .marshaledBlock(let l) = lhs, case .marshaledBlock(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.serializedBlock, .serializedBlock): return {
        guard case .serializedBlock(let l) = lhs, case .serializedBlock(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// State of the block in relation to the chain.
  enum TypeEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case connected // = 0
    case disconnected // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .connected
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .connected
      case 1: self = .disconnected
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .connected: return 0
      case .disconnected: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Pb_BlockNotification.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Pb_BlockNotification.TypeEnum] = [
    .connected,
    .disconnected,
  ]
}

#endif  // swift(>=4.2)

struct Pb_TransactionNotification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether or not the transaction has been included in a block.
  var type: Pb_TransactionNotification.TypeEnum = .unconfirmed

  var transaction: Pb_TransactionNotification.OneOf_Transaction? = nil

  /// A transaction included in a block.
  var confirmedTransaction: Pb_Transaction {
    get {
      if case .confirmedTransaction(let v)? = transaction {return v}
      return Pb_Transaction()
    }
    set {transaction = .confirmedTransaction(newValue)}
  }

  /// A transaction in mempool.
  var unconfirmedTransaction: Pb_MempoolTransaction {
    get {
      if case .unconfirmedTransaction(let v)? = transaction {return v}
      return Pb_MempoolTransaction()
    }
    set {transaction = .unconfirmedTransaction(newValue)}
  }

  /// Binary transaction, serialized using bitcoin protocol encoding.
  var serializedTransaction: Data {
    get {
      if case .serializedTransaction(let v)? = transaction {return v}
      return Data()
    }
    set {transaction = .serializedTransaction(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Transaction: Equatable {
    /// A transaction included in a block.
    case confirmedTransaction(Pb_Transaction)
    /// A transaction in mempool.
    case unconfirmedTransaction(Pb_MempoolTransaction)
    /// Binary transaction, serialized using bitcoin protocol encoding.
    case serializedTransaction(Data)

  #if !swift(>=4.1)
    static func ==(lhs: Pb_TransactionNotification.OneOf_Transaction, rhs: Pb_TransactionNotification.OneOf_Transaction) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.confirmedTransaction, .confirmedTransaction): return {
        guard case .confirmedTransaction(let l) = lhs, case .confirmedTransaction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.unconfirmedTransaction, .unconfirmedTransaction): return {
        guard case .unconfirmedTransaction(let l) = lhs, case .unconfirmedTransaction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.serializedTransaction, .serializedTransaction): return {
        guard case .serializedTransaction(let l) = lhs, case .serializedTransaction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// State of the transaction acceptance.
  enum TypeEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// A transaction in mempool.
    case unconfirmed // = 0

    /// A transaction in a block.
    case confirmed // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .unconfirmed
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unconfirmed
      case 1: self = .confirmed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unconfirmed: return 0
      case .confirmed: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Pb_TransactionNotification.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Pb_TransactionNotification.TypeEnum] = [
    .unconfirmed,
    .confirmed,
  ]
}

#endif  // swift(>=4.2)

/// Metadata for identifying and validating a block
struct Pb_BlockInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The double sha256 hash of the six header fields in the first 80 bytes
  /// of the block, when encoded according the bitcoin protocol, little-endian.
  /// sha256(sha256(encoded_header))
  var hash: Data = Data()

  /// The block number, an incremental index for each block mined.
  var height: Int32 = 0

  /// A version number to track software/protocol upgrades.
  var version: Int32 = 0

  /// Hash of the previous block, little-endian.
  var previousBlock: Data = Data()

  /// The root of the Merkle Tree built from all transactions in the block, little-endian.
  var merkleRoot: Data = Data()

  /// When mining of the block started, expressed in seconds since 1970-01-01.
  var timestamp: Int64 = 0

  /// Difficulty in Compressed Target Format.
  var bits: UInt32 = 0

  /// A random value that was generated during block mining which happened to
  /// result in a computed block hash below the difficulty target at the time.
  var nonce: UInt32 = 0

  /// Number of blocks in a chain, including the block itself upon creation.
  var confirmations: Int32 = 0

  /// Difficulty target at time of creation.
  var difficulty: Double = 0

  /// Hash of the next block in this chain, little-endian.
  var nextBlockHash: Data = Data()

  /// Size of the block in bytes.
  var size: Int32 = 0

  /// The median block time of the latest 11 block timestamps.
  var medianTime: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Pb_Block {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Block header data, as well as metadata stored by the node.
  var info: Pb_BlockInfo {
    get {return _info ?? Pb_BlockInfo()}
    set {_info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  var hasInfo: Bool {return self._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  mutating func clearInfo() {self._info = nil}

  /// List of transactions or transaction hashes.
  var transactionData: [Pb_Block.TransactionData] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct TransactionData {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var txidsOrTxs: Pb_Block.TransactionData.OneOf_TxidsOrTxs? = nil

    /// Just the transaction hash, little-endian.
    var transactionHash: Data {
      get {
        if case .transactionHash(let v)? = txidsOrTxs {return v}
        return Data()
      }
      set {txidsOrTxs = .transactionHash(newValue)}
    }

    /// A marshaled transaction.
    var transaction: Pb_Transaction {
      get {
        if case .transaction(let v)? = txidsOrTxs {return v}
        return Pb_Transaction()
      }
      set {txidsOrTxs = .transaction(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_TxidsOrTxs: Equatable {
      /// Just the transaction hash, little-endian.
      case transactionHash(Data)
      /// A marshaled transaction.
      case transaction(Pb_Transaction)

    #if !swift(>=4.1)
      static func ==(lhs: Pb_Block.TransactionData.OneOf_TxidsOrTxs, rhs: Pb_Block.TransactionData.OneOf_TxidsOrTxs) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.transactionHash, .transactionHash): return {
          guard case .transactionHash(let l) = lhs, case .transactionHash(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.transaction, .transaction): return {
          guard case .transaction(let l) = lhs, case .transaction(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    init() {}
  }

  init() {}

  fileprivate var _info: Pb_BlockInfo? = nil
}

struct Pb_Transaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The double sha256 hash of the encoded transaction, little-endian.
  /// sha256(sha256(encoded_transaction))
  var hash: Data {
    get {return _storage._hash}
    set {_uniqueStorage()._hash = newValue}
  }

  /// The version of the transaction format.
  var version: Int32 {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  /// List of inputs.
  var inputs: [Pb_Transaction.Input] {
    get {return _storage._inputs}
    set {_uniqueStorage()._inputs = newValue}
  }

  /// List of outputs.
  var outputs: [Pb_Transaction.Output] {
    get {return _storage._outputs}
    set {_uniqueStorage()._outputs = newValue}
  }

  /// The block height or timestamp after which this transaction is allowed.
  /// If value is greater than 500 million, it is assumed to be an epoch timestamp,
  /// otherwise it is treated as a block-height. Default is zero, or lock.
  var lockTime: UInt32 {
    get {return _storage._lockTime}
    set {_uniqueStorage()._lockTime = newValue}
  }

  /// The size of the transaction in bytes.
  var size: Int32 {
    get {return _storage._size}
    set {_uniqueStorage()._size = newValue}
  }

  /// When the transaction was included in a block, in epoch time.
  var timestamp: Int64 {
    get {return _storage._timestamp}
    set {_uniqueStorage()._timestamp = newValue}
  }

  /// Number of blocks including proof of the transaction, including
  /// the block it appeared.
  var confirmations: Int32 {
    get {return _storage._confirmations}
    set {_uniqueStorage()._confirmations = newValue}
  }

  /// Number of the block containing the transaction.
  var blockHeight: Int32 {
    get {return _storage._blockHeight}
    set {_uniqueStorage()._blockHeight = newValue}
  }

  /// Hash of the block the transaction was recorded in, little-endian.
  var blockHash: Data {
    get {return _storage._blockHash}
    set {_uniqueStorage()._blockHash = newValue}
  }

  var slpTransactionInfo: Pb_SlpTransactionInfo {
    get {return _storage._slpTransactionInfo ?? Pb_SlpTransactionInfo()}
    set {_uniqueStorage()._slpTransactionInfo = newValue}
  }
  /// Returns true if `slpTransactionInfo` has been explicitly set.
  var hasSlpTransactionInfo: Bool {return _storage._slpTransactionInfo != nil}
  /// Clears the value of `slpTransactionInfo`. Subsequent reads from it will return its default value.
  mutating func clearSlpTransactionInfo() {_uniqueStorage()._slpTransactionInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Input {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The number of the input, starting from zero.
    var index: UInt32 = 0

    /// The related outpoint.
    var outpoint: Pb_Transaction.Input.Outpoint {
      get {return _outpoint ?? Pb_Transaction.Input.Outpoint()}
      set {_outpoint = newValue}
    }
    /// Returns true if `outpoint` has been explicitly set.
    var hasOutpoint: Bool {return self._outpoint != nil}
    /// Clears the value of `outpoint`. Subsequent reads from it will return its default value.
    mutating func clearOutpoint() {self._outpoint = nil}

    /// An unlocking script asserting a transaction is permitted to spend
    /// the Outpoint (UTXO)
    var signatureScript: Data = Data()

    /// As of BIP-68, the sequence number is interpreted as a relative
    /// lock-time for the input.
    var sequence: UInt32 = 0

    /// Amount in satoshi.
    var value: Int64 = 0

    /// The pubkey_script of the previous output that is being spent.
    var previousScript: Data = Data()

    /// The bitcoin addresses associated with this input.
    var address: String = String()

    var slpToken: Pb_SlpToken {
      get {return _slpToken ?? Pb_SlpToken()}
      set {_slpToken = newValue}
    }
    /// Returns true if `slpToken` has been explicitly set.
    var hasSlpToken: Bool {return self._slpToken != nil}
    /// Clears the value of `slpToken`. Subsequent reads from it will return its default value.
    mutating func clearSlpToken() {self._slpToken = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct Outpoint {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The hash of the transaction containing the output to be spent, little-endian
      var hash: Data = Data()

      /// The index of specific output on the transaction.
      var index: UInt32 = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}

    fileprivate var _outpoint: Pb_Transaction.Input.Outpoint? = nil
    fileprivate var _slpToken: Pb_SlpToken? = nil
  }

  struct Output {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The number of the output, starting from zero.
    var index: UInt32 = 0

    /// The number of satoshis to be transferred.
    var value: Int64 = 0

    /// The public key script used to pay coins.
    var pubkeyScript: Data = Data()

    /// The bitcoin addresses associated with this output.
    var address: String = String()

    /// The type of script.
    var scriptClass: String = String()

    /// The script expressed in Bitcoin Cash Script.
    var disassembledScript: String = String()

    var slpToken: Pb_SlpToken {
      get {return _slpToken ?? Pb_SlpToken()}
      set {_slpToken = newValue}
    }
    /// Returns true if `slpToken` has been explicitly set.
    var hasSlpToken: Bool {return self._slpToken != nil}
    /// Clears the value of `slpToken`. Subsequent reads from it will return its default value.
    mutating func clearSlpToken() {self._slpToken = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _slpToken: Pb_SlpToken? = nil
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Pb_MempoolTransaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var transaction: Pb_Transaction {
    get {return _transaction ?? Pb_Transaction()}
    set {_transaction = newValue}
  }
  /// Returns true if `transaction` has been explicitly set.
  var hasTransaction: Bool {return self._transaction != nil}
  /// Clears the value of `transaction`. Subsequent reads from it will return its default value.
  mutating func clearTransaction() {self._transaction = nil}

  /// The time when the transaction was added too the pool.
  var addedTime: Int64 = 0

  /// The block height when the transaction was added to the pool.
  var addedHeight: Int32 = 0

  /// The total fee in satoshi the transaction pays.
  var fee: Int64 = 0

  /// The fee in satoshi per kilobyte the transaction pays.
  var feePerKb: Int64 = 0

  /// The priority of the transaction when it was added to the pool.
  var startingPriority: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _transaction: Pb_Transaction? = nil
}

struct Pb_UnspentOutput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A reference to the output given by transaction hash and index.
  var outpoint: Pb_Transaction.Input.Outpoint {
    get {return _outpoint ?? Pb_Transaction.Input.Outpoint()}
    set {_outpoint = newValue}
  }
  /// Returns true if `outpoint` has been explicitly set.
  var hasOutpoint: Bool {return self._outpoint != nil}
  /// Clears the value of `outpoint`. Subsequent reads from it will return its default value.
  mutating func clearOutpoint() {self._outpoint = nil}

  /// The public key script used to pay coins.
  var pubkeyScript: Data = Data()

  /// The amount in satoshis
  var value: Int64 = 0

  /// When is_coinbase is true, the output is the first in the block,
  /// a generation transaction, the result of mining.
  var isCoinbase: Bool = false

  /// The block number containing the UXTO.
  var blockHeight: Int32 = 0

  var slpToken: Pb_SlpToken {
    get {return _slpToken ?? Pb_SlpToken()}
    set {_slpToken = newValue}
  }
  /// Returns true if `slpToken` has been explicitly set.
  var hasSlpToken: Bool {return self._slpToken != nil}
  /// Clears the value of `slpToken`. Subsequent reads from it will return its default value.
  mutating func clearSlpToken() {self._slpToken = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _outpoint: Pb_Transaction.Input.Outpoint? = nil
  fileprivate var _slpToken: Pb_SlpToken? = nil
}

struct Pb_TransactionFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Filter by address(es)
  var addresses: [String] = []

  /// Filter by output hash and index.
  var outpoints: [Pb_Transaction.Input.Outpoint] = []

  /// Filter by data elements contained in pubkey scripts.
  var dataElements: [Data] = []

  /// Subscribed/Unsubscribe to everything. Other filters
  /// will be ignored.
  var allTransactions: Bool = false

  /// Subscribed/Unsubscribe to everything slp. Other filters
  /// will be ignored, except this filter will be overriden by all_transactions=true
  var allSlpTransactions: Bool = false

  /// only transactions associated with the included tokenIds
  var slpTokenIds: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// SlpToken info used in transaction inputs / outputs
///
/// WARNING: Some languages (e.g., JavaScript) may not properly handle the 'uint64'
/// for large amounts. For this reason, an annotation has been added for JS to
/// return a string for the amount field instead of casting uint64 to the JS 'number'
/// type. Other languages may require similar treatment.
struct Pb_SlpToken {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tokenID: Data = Data()

  var amount: UInt64 = 0

  var isMintBaton: Bool = false

  var address: String = String()

  var decimals: UInt32 = 0

  var slpAction: Pb_SlpAction = .nonSlp

  var tokenType: Pb_SlpTokenType = .versionNotSet

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// SlpTransactionInfo is used inside the Transaction message type.
struct Pb_SlpTransactionInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var slpAction: Pb_SlpAction = .nonSlp

  var validityJudgement: Pb_SlpTransactionInfo.ValidityJudgement = .unknownOrInvalid

  var parseError: String = String()

  var tokenID: Data = Data()

  var burnFlags: [Pb_SlpTransactionInfo.BurnFlags] = []

  var txMetadata: Pb_SlpTransactionInfo.OneOf_TxMetadata? = nil

  /// NFT1 Group also uses this
  var v1Genesis: Pb_SlpV1GenesisMetadata {
    get {
      if case .v1Genesis(let v)? = txMetadata {return v}
      return Pb_SlpV1GenesisMetadata()
    }
    set {txMetadata = .v1Genesis(newValue)}
  }

  /// NFT1 Group also uses this
  var v1Mint: Pb_SlpV1MintMetadata {
    get {
      if case .v1Mint(let v)? = txMetadata {return v}
      return Pb_SlpV1MintMetadata()
    }
    set {txMetadata = .v1Mint(newValue)}
  }

  /// NFT1 Group also uses this
  var v1Send: Pb_SlpV1SendMetadata {
    get {
      if case .v1Send(let v)? = txMetadata {return v}
      return Pb_SlpV1SendMetadata()
    }
    set {txMetadata = .v1Send(newValue)}
  }

  var v1Nft1ChildGenesis: Pb_SlpV1Nft1ChildGenesisMetadata {
    get {
      if case .v1Nft1ChildGenesis(let v)? = txMetadata {return v}
      return Pb_SlpV1Nft1ChildGenesisMetadata()
    }
    set {txMetadata = .v1Nft1ChildGenesis(newValue)}
  }

  var v1Nft1ChildSend: Pb_SlpV1Nft1ChildSendMetadata {
    get {
      if case .v1Nft1ChildSend(let v)? = txMetadata {return v}
      return Pb_SlpV1Nft1ChildSendMetadata()
    }
    set {txMetadata = .v1Nft1ChildSend(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_TxMetadata: Equatable {
    /// NFT1 Group also uses this
    case v1Genesis(Pb_SlpV1GenesisMetadata)
    /// NFT1 Group also uses this
    case v1Mint(Pb_SlpV1MintMetadata)
    /// NFT1 Group also uses this
    case v1Send(Pb_SlpV1SendMetadata)
    case v1Nft1ChildGenesis(Pb_SlpV1Nft1ChildGenesisMetadata)
    case v1Nft1ChildSend(Pb_SlpV1Nft1ChildSendMetadata)

  #if !swift(>=4.1)
    static func ==(lhs: Pb_SlpTransactionInfo.OneOf_TxMetadata, rhs: Pb_SlpTransactionInfo.OneOf_TxMetadata) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.v1Genesis, .v1Genesis): return {
        guard case .v1Genesis(let l) = lhs, case .v1Genesis(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.v1Mint, .v1Mint): return {
        guard case .v1Mint(let l) = lhs, case .v1Mint(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.v1Send, .v1Send): return {
        guard case .v1Send(let l) = lhs, case .v1Send(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.v1Nft1ChildGenesis, .v1Nft1ChildGenesis): return {
        guard case .v1Nft1ChildGenesis(let l) = lhs, case .v1Nft1ChildGenesis(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.v1Nft1ChildSend, .v1Nft1ChildSend): return {
        guard case .v1Nft1ChildSend(let l) = lhs, case .v1Nft1ChildSend(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  enum ValidityJudgement: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknownOrInvalid // = 0
    case valid // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .unknownOrInvalid
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownOrInvalid
      case 1: self = .valid
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknownOrInvalid: return 0
      case .valid: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  enum BurnFlags: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case burnedInputsOutputsTooHigh // = 0
    case burnedInputsBadOpreturn // = 1
    case burnedInputsOtherToken // = 2
    case burnedOutputsMissingBchVout // = 3
    case burnedInputsGreaterThanOutputs // = 4
    case UNRECOGNIZED(Int)

    init() {
      self = .burnedInputsOutputsTooHigh
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .burnedInputsOutputsTooHigh
      case 1: self = .burnedInputsBadOpreturn
      case 2: self = .burnedInputsOtherToken
      case 3: self = .burnedOutputsMissingBchVout
      case 4: self = .burnedInputsGreaterThanOutputs
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .burnedInputsOutputsTooHigh: return 0
      case .burnedInputsBadOpreturn: return 1
      case .burnedInputsOtherToken: return 2
      case .burnedOutputsMissingBchVout: return 3
      case .burnedInputsGreaterThanOutputs: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Pb_SlpTransactionInfo.ValidityJudgement: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Pb_SlpTransactionInfo.ValidityJudgement] = [
    .unknownOrInvalid,
    .valid,
  ]
}

extension Pb_SlpTransactionInfo.BurnFlags: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Pb_SlpTransactionInfo.BurnFlags] = [
    .burnedInputsOutputsTooHigh,
    .burnedInputsBadOpreturn,
    .burnedInputsOtherToken,
    .burnedOutputsMissingBchVout,
    .burnedInputsGreaterThanOutputs,
  ]
}

#endif  // swift(>=4.2)

/// SlpV1GenesisMetadata is used to marshal type 1 and NFT1 Group GENESIS OP_RETURN scriptPubKey
struct Pb_SlpV1GenesisMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: Data = Data()

  var ticker: Data = Data()

  var documentURL: Data = Data()

  var documentHash: Data = Data()

  var decimals: UInt32 = 0

  var mintBatonVout: UInt32 = 0

  var mintAmount: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// SlpV1MintMetadata is used to marshal type 1 MINT OP_RETURN scriptPubKey
struct Pb_SlpV1MintMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mintBatonVout: UInt32 = 0

  var mintAmount: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// SlpV1SendMetadata is used to marshal type 1 and NFT1 Group SEND OP_RETURN scriptPubKey
struct Pb_SlpV1SendMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var amounts: [UInt64] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// SlpV1Nft1ChildGenesisMetadata is used to marshal NFT1 Child GENESIS OP_RETURN scriptPubKey
struct Pb_SlpV1Nft1ChildGenesisMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: Data = Data()

  var ticker: Data = Data()

  var documentURL: Data = Data()

  var documentHash: Data = Data()

  var decimals: UInt32 = 0

  var groupTokenID: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// SlpV1Nft1ChildSendMetadata is used to marshal NFT1 Child SEND OP_RETURN scriptPubKey
struct Pb_SlpV1Nft1ChildSendMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var groupTokenID: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// SlpTokenMetadata is used to marshal metadata about a specific TokenID
struct Pb_SlpTokenMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tokenID: Data = Data()

  var tokenType: Pb_SlpTokenType = .versionNotSet

  var typeMetadata: Pb_SlpTokenMetadata.OneOf_TypeMetadata? = nil

  var v1Fungible: Pb_SlpTokenMetadata.V1Fungible {
    get {
      if case .v1Fungible(let v)? = typeMetadata {return v}
      return Pb_SlpTokenMetadata.V1Fungible()
    }
    set {typeMetadata = .v1Fungible(newValue)}
  }

  var v1Nft1Group: Pb_SlpTokenMetadata.V1NFT1Group {
    get {
      if case .v1Nft1Group(let v)? = typeMetadata {return v}
      return Pb_SlpTokenMetadata.V1NFT1Group()
    }
    set {typeMetadata = .v1Nft1Group(newValue)}
  }

  var v1Nft1Child: Pb_SlpTokenMetadata.V1NFT1Child {
    get {
      if case .v1Nft1Child(let v)? = typeMetadata {return v}
      return Pb_SlpTokenMetadata.V1NFT1Child()
    }
    set {typeMetadata = .v1Nft1Child(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_TypeMetadata: Equatable {
    case v1Fungible(Pb_SlpTokenMetadata.V1Fungible)
    case v1Nft1Group(Pb_SlpTokenMetadata.V1NFT1Group)
    case v1Nft1Child(Pb_SlpTokenMetadata.V1NFT1Child)

  #if !swift(>=4.1)
    static func ==(lhs: Pb_SlpTokenMetadata.OneOf_TypeMetadata, rhs: Pb_SlpTokenMetadata.OneOf_TypeMetadata) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.v1Fungible, .v1Fungible): return {
        guard case .v1Fungible(let l) = lhs, case .v1Fungible(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.v1Nft1Group, .v1Nft1Group): return {
        guard case .v1Nft1Group(let l) = lhs, case .v1Nft1Group(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.v1Nft1Child, .v1Nft1Child): return {
        guard case .v1Nft1Child(let l) = lhs, case .v1Nft1Child(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// V1Fungible is used to marshal metadata specific to Type 1 token IDs
  struct V1Fungible {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var tokenTicker: String = String()

    var tokenName: String = String()

    var tokenDocumentURL: String = String()

    var tokenDocumentHash: Data = Data()

    var decimals: UInt32 = 0

    var mintBatonHash: Data = Data()

    var mintBatonVout: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// V1NFT1Group is used to marshal metadata specific to NFT1 Group token IDs
  struct V1NFT1Group {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var tokenTicker: String = String()

    var tokenName: String = String()

    var tokenDocumentURL: String = String()

    var tokenDocumentHash: Data = Data()

    var decimals: UInt32 = 0

    var mintBatonHash: Data = Data()

    var mintBatonVout: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// V1NFT1Child is used to marshal metadata specific to NFT1 Child token IDs
  struct V1NFT1Child {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var tokenTicker: String = String()

    var tokenName: String = String()

    var tokenDocumentURL: String = String()

    var tokenDocumentHash: Data = Data()

    var groupID: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

/// SlpRequiredBurn is used by clients to allow token burning
struct Pb_SlpRequiredBurn {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var outpoint: Pb_Transaction.Input.Outpoint {
    get {return _outpoint ?? Pb_Transaction.Input.Outpoint()}
    set {_outpoint = newValue}
  }
  /// Returns true if `outpoint` has been explicitly set.
  var hasOutpoint: Bool {return self._outpoint != nil}
  /// Clears the value of `outpoint`. Subsequent reads from it will return its default value.
  mutating func clearOutpoint() {self._outpoint = nil}

  var tokenID: Data = Data()

  var tokenType: Pb_SlpTokenType = .versionNotSet

  var burnIntention: Pb_SlpRequiredBurn.OneOf_BurnIntention? = nil

  var amount: UInt64 {
    get {
      if case .amount(let v)? = burnIntention {return v}
      return 0
    }
    set {burnIntention = .amount(newValue)}
  }

  var mintBatonVout: UInt32 {
    get {
      if case .mintBatonVout(let v)? = burnIntention {return v}
      return 0
    }
    set {burnIntention = .mintBatonVout(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_BurnIntention: Equatable {
    case amount(UInt64)
    case mintBatonVout(UInt32)

  #if !swift(>=4.1)
    static func ==(lhs: Pb_SlpRequiredBurn.OneOf_BurnIntention, rhs: Pb_SlpRequiredBurn.OneOf_BurnIntention) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.amount, .amount): return {
        guard case .amount(let l) = lhs, case .amount(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.mintBatonVout, .mintBatonVout): return {
        guard case .mintBatonVout(let l) = lhs, case .mintBatonVout(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _outpoint: Pb_Transaction.Input.Outpoint? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "pb"

extension Pb_SlpTokenType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VERSION_NOT_SET"),
    1: .same(proto: "V1_FUNGIBLE"),
    65: .same(proto: "V1_NFT1_CHILD"),
    129: .same(proto: "V1_NFT1_GROUP"),
  ]
}

extension Pb_SlpAction: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NON_SLP"),
    1: .same(proto: "NON_SLP_BURN"),
    2: .same(proto: "SLP_PARSE_ERROR"),
    3: .same(proto: "SLP_UNSUPPORTED_VERSION"),
    4: .same(proto: "SLP_V1_GENESIS"),
    5: .same(proto: "SLP_V1_MINT"),
    6: .same(proto: "SLP_V1_SEND"),
    7: .same(proto: "SLP_V1_NFT1_GROUP_GENESIS"),
    8: .same(proto: "SLP_V1_NFT1_GROUP_MINT"),
    9: .same(proto: "SLP_V1_NFT1_GROUP_SEND"),
    10: .same(proto: "SLP_V1_NFT1_UNIQUE_CHILD_GENESIS"),
    11: .same(proto: "SLP_V1_NFT1_UNIQUE_CHILD_SEND"),
  ]
}

extension Pb_GetMempoolInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetMempoolInfoRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_GetMempoolInfoRequest, rhs: Pb_GetMempoolInfoRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_GetMempoolInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetMempoolInfoResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "size"),
    2: .same(proto: "bytes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.size) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.bytes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.size != 0 {
      try visitor.visitSingularUInt32Field(value: self.size, fieldNumber: 1)
    }
    if self.bytes != 0 {
      try visitor.visitSingularUInt32Field(value: self.bytes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_GetMempoolInfoResponse, rhs: Pb_GetMempoolInfoResponse) -> Bool {
    if lhs.size != rhs.size {return false}
    if lhs.bytes != rhs.bytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_GetMempoolRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetMempoolRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "full_transactions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.fullTransactions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.fullTransactions != false {
      try visitor.visitSingularBoolField(value: self.fullTransactions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_GetMempoolRequest, rhs: Pb_GetMempoolRequest) -> Bool {
    if lhs.fullTransactions != rhs.fullTransactions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_GetMempoolResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetMempoolResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transaction_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.transactionData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transactionData.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.transactionData, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_GetMempoolResponse, rhs: Pb_GetMempoolResponse) -> Bool {
    if lhs.transactionData != rhs.transactionData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_GetMempoolResponse.TransactionData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Pb_GetMempoolResponse.protoMessageName + ".TransactionData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transaction_hash"),
    2: .same(proto: "transaction"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.txidsOrTxs != nil {try decoder.handleConflictingOneOf()}
          self.txidsOrTxs = .transactionHash(v)
        }
      }()
      case 2: try {
        var v: Pb_Transaction?
        var hadOneofValue = false
        if let current = self.txidsOrTxs {
          hadOneofValue = true
          if case .transaction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.txidsOrTxs = .transaction(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.txidsOrTxs {
    case .transactionHash?: try {
      guard case .transactionHash(let v)? = self.txidsOrTxs else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }()
    case .transaction?: try {
      guard case .transaction(let v)? = self.txidsOrTxs else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_GetMempoolResponse.TransactionData, rhs: Pb_GetMempoolResponse.TransactionData) -> Bool {
    if lhs.txidsOrTxs != rhs.txidsOrTxs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_GetBlockchainInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetBlockchainInfoRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_GetBlockchainInfoRequest, rhs: Pb_GetBlockchainInfoRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_GetBlockchainInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetBlockchainInfoResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bitcoin_net"),
    2: .standard(proto: "best_height"),
    3: .standard(proto: "best_block_hash"),
    4: .same(proto: "difficulty"),
    5: .standard(proto: "median_time"),
    6: .standard(proto: "tx_index"),
    7: .standard(proto: "addr_index"),
    8: .standard(proto: "slp_index"),
    9: .standard(proto: "slp_graphsearch"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.bitcoinNet) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.bestHeight) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.bestBlockHash) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.difficulty) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.medianTime) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.txIndex) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.addrIndex) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.slpIndex) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.slpGraphsearch) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.bitcoinNet != .mainnet {
      try visitor.visitSingularEnumField(value: self.bitcoinNet, fieldNumber: 1)
    }
    if self.bestHeight != 0 {
      try visitor.visitSingularInt32Field(value: self.bestHeight, fieldNumber: 2)
    }
    if !self.bestBlockHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.bestBlockHash, fieldNumber: 3)
    }
    if self.difficulty != 0 {
      try visitor.visitSingularDoubleField(value: self.difficulty, fieldNumber: 4)
    }
    if self.medianTime != 0 {
      try visitor.visitSingularInt64Field(value: self.medianTime, fieldNumber: 5)
    }
    if self.txIndex != false {
      try visitor.visitSingularBoolField(value: self.txIndex, fieldNumber: 6)
    }
    if self.addrIndex != false {
      try visitor.visitSingularBoolField(value: self.addrIndex, fieldNumber: 7)
    }
    if self.slpIndex != false {
      try visitor.visitSingularBoolField(value: self.slpIndex, fieldNumber: 8)
    }
    if self.slpGraphsearch != false {
      try visitor.visitSingularBoolField(value: self.slpGraphsearch, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_GetBlockchainInfoResponse, rhs: Pb_GetBlockchainInfoResponse) -> Bool {
    if lhs.bitcoinNet != rhs.bitcoinNet {return false}
    if lhs.bestHeight != rhs.bestHeight {return false}
    if lhs.bestBlockHash != rhs.bestBlockHash {return false}
    if lhs.difficulty != rhs.difficulty {return false}
    if lhs.medianTime != rhs.medianTime {return false}
    if lhs.txIndex != rhs.txIndex {return false}
    if lhs.addrIndex != rhs.addrIndex {return false}
    if lhs.slpIndex != rhs.slpIndex {return false}
    if lhs.slpGraphsearch != rhs.slpGraphsearch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_GetBlockchainInfoResponse.BitcoinNet: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MAINNET"),
    1: .same(proto: "REGTEST"),
    2: .same(proto: "TESTNET3"),
    3: .same(proto: "SIMNET"),
  ]
}

extension Pb_GetBlockInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetBlockInfoRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "height"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.hashOrHeight != nil {try decoder.handleConflictingOneOf()}
          self.hashOrHeight = .hash(v)
        }
      }()
      case 2: try {
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {
          if self.hashOrHeight != nil {try decoder.handleConflictingOneOf()}
          self.hashOrHeight = .height(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.hashOrHeight {
    case .hash?: try {
      guard case .hash(let v)? = self.hashOrHeight else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }()
    case .height?: try {
      guard case .height(let v)? = self.hashOrHeight else { preconditionFailure() }
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_GetBlockInfoRequest, rhs: Pb_GetBlockInfoRequest) -> Bool {
    if lhs.hashOrHeight != rhs.hashOrHeight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_GetBlockInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetBlockInfoResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "info"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_GetBlockInfoResponse, rhs: Pb_GetBlockInfoResponse) -> Bool {
    if lhs._info != rhs._info {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_GetBlockRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetBlockRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "height"),
    3: .standard(proto: "full_transactions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.hashOrHeight != nil {try decoder.handleConflictingOneOf()}
          self.hashOrHeight = .hash(v)
        }
      }()
      case 2: try {
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {
          if self.hashOrHeight != nil {try decoder.handleConflictingOneOf()}
          self.hashOrHeight = .height(v)
        }
      }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.fullTransactions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.hashOrHeight {
    case .hash?: try {
      guard case .hash(let v)? = self.hashOrHeight else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }()
    case .height?: try {
      guard case .height(let v)? = self.hashOrHeight else { preconditionFailure() }
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    if self.fullTransactions != false {
      try visitor.visitSingularBoolField(value: self.fullTransactions, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_GetBlockRequest, rhs: Pb_GetBlockRequest) -> Bool {
    if lhs.hashOrHeight != rhs.hashOrHeight {return false}
    if lhs.fullTransactions != rhs.fullTransactions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_GetBlockResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetBlockResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "block"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._block) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._block {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_GetBlockResponse, rhs: Pb_GetBlockResponse) -> Bool {
    if lhs._block != rhs._block {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_GetRawBlockRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetRawBlockRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "height"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.hashOrHeight != nil {try decoder.handleConflictingOneOf()}
          self.hashOrHeight = .hash(v)
        }
      }()
      case 2: try {
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {
          if self.hashOrHeight != nil {try decoder.handleConflictingOneOf()}
          self.hashOrHeight = .height(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.hashOrHeight {
    case .hash?: try {
      guard case .hash(let v)? = self.hashOrHeight else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }()
    case .height?: try {
      guard case .height(let v)? = self.hashOrHeight else { preconditionFailure() }
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_GetRawBlockRequest, rhs: Pb_GetRawBlockRequest) -> Bool {
    if lhs.hashOrHeight != rhs.hashOrHeight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_GetRawBlockResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetRawBlockResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "block"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.block) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.block.isEmpty {
      try visitor.visitSingularBytesField(value: self.block, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_GetRawBlockResponse, rhs: Pb_GetRawBlockResponse) -> Bool {
    if lhs.block != rhs.block {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_GetBlockFilterRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetBlockFilterRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "height"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.hashOrHeight != nil {try decoder.handleConflictingOneOf()}
          self.hashOrHeight = .hash(v)
        }
      }()
      case 2: try {
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {
          if self.hashOrHeight != nil {try decoder.handleConflictingOneOf()}
          self.hashOrHeight = .height(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.hashOrHeight {
    case .hash?: try {
      guard case .hash(let v)? = self.hashOrHeight else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }()
    case .height?: try {
      guard case .height(let v)? = self.hashOrHeight else { preconditionFailure() }
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_GetBlockFilterRequest, rhs: Pb_GetBlockFilterRequest) -> Bool {
    if lhs.hashOrHeight != rhs.hashOrHeight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_GetBlockFilterResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetBlockFilterResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "filter"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.filter) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.filter.isEmpty {
      try visitor.visitSingularBytesField(value: self.filter, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_GetBlockFilterResponse, rhs: Pb_GetBlockFilterResponse) -> Bool {
    if lhs.filter != rhs.filter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_GetHeadersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetHeadersRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "block_locator_hashes"),
    2: .standard(proto: "stop_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBytesField(value: &self.blockLocatorHashes) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.stopHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.blockLocatorHashes.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.blockLocatorHashes, fieldNumber: 1)
    }
    if !self.stopHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.stopHash, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_GetHeadersRequest, rhs: Pb_GetHeadersRequest) -> Bool {
    if lhs.blockLocatorHashes != rhs.blockLocatorHashes {return false}
    if lhs.stopHash != rhs.stopHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_GetHeadersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetHeadersResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "headers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.headers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.headers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.headers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_GetHeadersResponse, rhs: Pb_GetHeadersResponse) -> Bool {
    if lhs.headers != rhs.headers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_GetTransactionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetTransactionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .standard(proto: "include_token_metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.hash) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.includeTokenMetadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 1)
    }
    if self.includeTokenMetadata != false {
      try visitor.visitSingularBoolField(value: self.includeTokenMetadata, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_GetTransactionRequest, rhs: Pb_GetTransactionRequest) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.includeTokenMetadata != rhs.includeTokenMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_GetTransactionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetTransactionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transaction"),
    2: .standard(proto: "token_metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._transaction) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._tokenMetadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._transaction {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._tokenMetadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_GetTransactionResponse, rhs: Pb_GetTransactionResponse) -> Bool {
    if lhs._transaction != rhs._transaction {return false}
    if lhs._tokenMetadata != rhs._tokenMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_GetRawTransactionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetRawTransactionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.hash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_GetRawTransactionRequest, rhs: Pb_GetRawTransactionRequest) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_GetRawTransactionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetRawTransactionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transaction"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.transaction) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transaction.isEmpty {
      try visitor.visitSingularBytesField(value: self.transaction, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_GetRawTransactionResponse, rhs: Pb_GetRawTransactionResponse) -> Bool {
    if lhs.transaction != rhs.transaction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_GetAddressTransactionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAddressTransactionsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .standard(proto: "nb_skip"),
    3: .standard(proto: "nb_fetch"),
    4: .same(proto: "hash"),
    5: .same(proto: "height"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.nbSkip) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.nbFetch) }()
      case 4: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.startBlock != nil {try decoder.handleConflictingOneOf()}
          self.startBlock = .hash(v)
        }
      }()
      case 5: try {
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {
          if self.startBlock != nil {try decoder.handleConflictingOneOf()}
          self.startBlock = .height(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if self.nbSkip != 0 {
      try visitor.visitSingularUInt32Field(value: self.nbSkip, fieldNumber: 2)
    }
    if self.nbFetch != 0 {
      try visitor.visitSingularUInt32Field(value: self.nbFetch, fieldNumber: 3)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.startBlock {
    case .hash?: try {
      guard case .hash(let v)? = self.startBlock else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    }()
    case .height?: try {
      guard case .height(let v)? = self.startBlock else { preconditionFailure() }
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_GetAddressTransactionsRequest, rhs: Pb_GetAddressTransactionsRequest) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.nbSkip != rhs.nbSkip {return false}
    if lhs.nbFetch != rhs.nbFetch {return false}
    if lhs.startBlock != rhs.startBlock {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_GetAddressTransactionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAddressTransactionsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "confirmed_transactions"),
    2: .standard(proto: "unconfirmed_transactions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.confirmedTransactions) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.unconfirmedTransactions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.confirmedTransactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.confirmedTransactions, fieldNumber: 1)
    }
    if !self.unconfirmedTransactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.unconfirmedTransactions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_GetAddressTransactionsResponse, rhs: Pb_GetAddressTransactionsResponse) -> Bool {
    if lhs.confirmedTransactions != rhs.confirmedTransactions {return false}
    if lhs.unconfirmedTransactions != rhs.unconfirmedTransactions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_GetRawAddressTransactionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetRawAddressTransactionsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .standard(proto: "nb_skip"),
    3: .standard(proto: "nb_fetch"),
    4: .same(proto: "hash"),
    5: .same(proto: "height"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.nbSkip) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.nbFetch) }()
      case 4: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.startBlock != nil {try decoder.handleConflictingOneOf()}
          self.startBlock = .hash(v)
        }
      }()
      case 5: try {
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {
          if self.startBlock != nil {try decoder.handleConflictingOneOf()}
          self.startBlock = .height(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if self.nbSkip != 0 {
      try visitor.visitSingularUInt32Field(value: self.nbSkip, fieldNumber: 2)
    }
    if self.nbFetch != 0 {
      try visitor.visitSingularUInt32Field(value: self.nbFetch, fieldNumber: 3)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.startBlock {
    case .hash?: try {
      guard case .hash(let v)? = self.startBlock else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    }()
    case .height?: try {
      guard case .height(let v)? = self.startBlock else { preconditionFailure() }
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_GetRawAddressTransactionsRequest, rhs: Pb_GetRawAddressTransactionsRequest) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.nbSkip != rhs.nbSkip {return false}
    if lhs.nbFetch != rhs.nbFetch {return false}
    if lhs.startBlock != rhs.startBlock {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_GetRawAddressTransactionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetRawAddressTransactionsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "confirmed_transactions"),
    2: .standard(proto: "unconfirmed_transactions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBytesField(value: &self.confirmedTransactions) }()
      case 2: try { try decoder.decodeRepeatedBytesField(value: &self.unconfirmedTransactions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.confirmedTransactions.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.confirmedTransactions, fieldNumber: 1)
    }
    if !self.unconfirmedTransactions.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.unconfirmedTransactions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_GetRawAddressTransactionsResponse, rhs: Pb_GetRawAddressTransactionsResponse) -> Bool {
    if lhs.confirmedTransactions != rhs.confirmedTransactions {return false}
    if lhs.unconfirmedTransactions != rhs.unconfirmedTransactions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_GetAddressUnspentOutputsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAddressUnspentOutputsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .standard(proto: "include_mempool"),
    3: .standard(proto: "include_token_metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.includeMempool) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.includeTokenMetadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if self.includeMempool != false {
      try visitor.visitSingularBoolField(value: self.includeMempool, fieldNumber: 2)
    }
    if self.includeTokenMetadata != false {
      try visitor.visitSingularBoolField(value: self.includeTokenMetadata, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_GetAddressUnspentOutputsRequest, rhs: Pb_GetAddressUnspentOutputsRequest) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.includeMempool != rhs.includeMempool {return false}
    if lhs.includeTokenMetadata != rhs.includeTokenMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_GetAddressUnspentOutputsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAddressUnspentOutputsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "outputs"),
    2: .standard(proto: "token_metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.outputs) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.tokenMetadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.outputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.outputs, fieldNumber: 1)
    }
    if !self.tokenMetadata.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tokenMetadata, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_GetAddressUnspentOutputsResponse, rhs: Pb_GetAddressUnspentOutputsResponse) -> Bool {
    if lhs.outputs != rhs.outputs {return false}
    if lhs.tokenMetadata != rhs.tokenMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_GetUnspentOutputRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetUnspentOutputRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "index"),
    3: .standard(proto: "include_mempool"),
    4: .standard(proto: "include_token_metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.hash) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.index) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.includeMempool) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.includeTokenMetadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 1)
    }
    if self.index != 0 {
      try visitor.visitSingularUInt32Field(value: self.index, fieldNumber: 2)
    }
    if self.includeMempool != false {
      try visitor.visitSingularBoolField(value: self.includeMempool, fieldNumber: 3)
    }
    if self.includeTokenMetadata != false {
      try visitor.visitSingularBoolField(value: self.includeTokenMetadata, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_GetUnspentOutputRequest, rhs: Pb_GetUnspentOutputRequest) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.index != rhs.index {return false}
    if lhs.includeMempool != rhs.includeMempool {return false}
    if lhs.includeTokenMetadata != rhs.includeTokenMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_GetUnspentOutputResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetUnspentOutputResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "outpoint"),
    2: .standard(proto: "pubkey_script"),
    3: .same(proto: "value"),
    4: .standard(proto: "is_coinbase"),
    5: .standard(proto: "block_height"),
    6: .standard(proto: "slp_token"),
    7: .standard(proto: "token_metadata"),
  ]

  fileprivate class _StorageClass {
    var _outpoint: Pb_Transaction.Input.Outpoint? = nil
    var _pubkeyScript: Data = Data()
    var _value: Int64 = 0
    var _isCoinbase: Bool = false
    var _blockHeight: Int32 = 0
    var _slpToken: Pb_SlpToken? = nil
    var _tokenMetadata: Pb_SlpTokenMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _outpoint = source._outpoint
      _pubkeyScript = source._pubkeyScript
      _value = source._value
      _isCoinbase = source._isCoinbase
      _blockHeight = source._blockHeight
      _slpToken = source._slpToken
      _tokenMetadata = source._tokenMetadata
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._outpoint) }()
        case 2: try { try decoder.decodeSingularBytesField(value: &_storage._pubkeyScript) }()
        case 3: try { try decoder.decodeSingularInt64Field(value: &_storage._value) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._isCoinbase) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._blockHeight) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._slpToken) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._tokenMetadata) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._outpoint {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._pubkeyScript.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._pubkeyScript, fieldNumber: 2)
      }
      if _storage._value != 0 {
        try visitor.visitSingularInt64Field(value: _storage._value, fieldNumber: 3)
      }
      if _storage._isCoinbase != false {
        try visitor.visitSingularBoolField(value: _storage._isCoinbase, fieldNumber: 4)
      }
      if _storage._blockHeight != 0 {
        try visitor.visitSingularInt32Field(value: _storage._blockHeight, fieldNumber: 5)
      }
      if let v = _storage._slpToken {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._tokenMetadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_GetUnspentOutputResponse, rhs: Pb_GetUnspentOutputResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._outpoint != rhs_storage._outpoint {return false}
        if _storage._pubkeyScript != rhs_storage._pubkeyScript {return false}
        if _storage._value != rhs_storage._value {return false}
        if _storage._isCoinbase != rhs_storage._isCoinbase {return false}
        if _storage._blockHeight != rhs_storage._blockHeight {return false}
        if _storage._slpToken != rhs_storage._slpToken {return false}
        if _storage._tokenMetadata != rhs_storage._tokenMetadata {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_GetMerkleProofRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetMerkleProofRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transaction_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.transactionHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transactionHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.transactionHash, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_GetMerkleProofRequest, rhs: Pb_GetMerkleProofRequest) -> Bool {
    if lhs.transactionHash != rhs.transactionHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_GetMerkleProofResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetMerkleProofResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "block"),
    2: .same(proto: "hashes"),
    3: .same(proto: "flags"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._block) }()
      case 2: try { try decoder.decodeRepeatedBytesField(value: &self.hashes) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.flags) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._block {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.hashes.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.hashes, fieldNumber: 2)
    }
    if !self.flags.isEmpty {
      try visitor.visitSingularBytesField(value: self.flags, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_GetMerkleProofResponse, rhs: Pb_GetMerkleProofResponse) -> Bool {
    if lhs._block != rhs._block {return false}
    if lhs.hashes != rhs.hashes {return false}
    if lhs.flags != rhs.flags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_SubmitTransactionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubmitTransactionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transaction"),
    2: .standard(proto: "skip_slp_validity_check"),
    3: .standard(proto: "required_slp_burns"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.transaction) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.skipSlpValidityCheck) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.requiredSlpBurns) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transaction.isEmpty {
      try visitor.visitSingularBytesField(value: self.transaction, fieldNumber: 1)
    }
    if self.skipSlpValidityCheck != false {
      try visitor.visitSingularBoolField(value: self.skipSlpValidityCheck, fieldNumber: 2)
    }
    if !self.requiredSlpBurns.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.requiredSlpBurns, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_SubmitTransactionRequest, rhs: Pb_SubmitTransactionRequest) -> Bool {
    if lhs.transaction != rhs.transaction {return false}
    if lhs.skipSlpValidityCheck != rhs.skipSlpValidityCheck {return false}
    if lhs.requiredSlpBurns != rhs.requiredSlpBurns {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_SubmitTransactionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubmitTransactionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.hash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_SubmitTransactionResponse, rhs: Pb_SubmitTransactionResponse) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_CheckSlpTransactionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CheckSlpTransactionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transaction"),
    2: .standard(proto: "required_slp_burns"),
    3: .standard(proto: "use_spec_validity_judgement"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.transaction) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.requiredSlpBurns) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.useSpecValidityJudgement) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transaction.isEmpty {
      try visitor.visitSingularBytesField(value: self.transaction, fieldNumber: 1)
    }
    if !self.requiredSlpBurns.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.requiredSlpBurns, fieldNumber: 2)
    }
    if self.useSpecValidityJudgement != false {
      try visitor.visitSingularBoolField(value: self.useSpecValidityJudgement, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_CheckSlpTransactionRequest, rhs: Pb_CheckSlpTransactionRequest) -> Bool {
    if lhs.transaction != rhs.transaction {return false}
    if lhs.requiredSlpBurns != rhs.requiredSlpBurns {return false}
    if lhs.useSpecValidityJudgement != rhs.useSpecValidityJudgement {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_CheckSlpTransactionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CheckSlpTransactionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_valid"),
    2: .standard(proto: "invalid_reason"),
    3: .standard(proto: "best_height"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isValid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.invalidReason) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.bestHeight) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isValid != false {
      try visitor.visitSingularBoolField(value: self.isValid, fieldNumber: 1)
    }
    if !self.invalidReason.isEmpty {
      try visitor.visitSingularStringField(value: self.invalidReason, fieldNumber: 2)
    }
    if self.bestHeight != 0 {
      try visitor.visitSingularInt32Field(value: self.bestHeight, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_CheckSlpTransactionResponse, rhs: Pb_CheckSlpTransactionResponse) -> Bool {
    if lhs.isValid != rhs.isValid {return false}
    if lhs.invalidReason != rhs.invalidReason {return false}
    if lhs.bestHeight != rhs.bestHeight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_SubscribeTransactionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscribeTransactionsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subscribe"),
    2: .same(proto: "unsubscribe"),
    3: .standard(proto: "include_mempool"),
    4: .standard(proto: "include_in_block"),
    5: .standard(proto: "serialize_tx"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._subscribe) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._unsubscribe) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.includeMempool) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.includeInBlock) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.serializeTx) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._subscribe {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._unsubscribe {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.includeMempool != false {
      try visitor.visitSingularBoolField(value: self.includeMempool, fieldNumber: 3)
    }
    if self.includeInBlock != false {
      try visitor.visitSingularBoolField(value: self.includeInBlock, fieldNumber: 4)
    }
    if self.serializeTx != false {
      try visitor.visitSingularBoolField(value: self.serializeTx, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_SubscribeTransactionsRequest, rhs: Pb_SubscribeTransactionsRequest) -> Bool {
    if lhs._subscribe != rhs._subscribe {return false}
    if lhs._unsubscribe != rhs._unsubscribe {return false}
    if lhs.includeMempool != rhs.includeMempool {return false}
    if lhs.includeInBlock != rhs.includeInBlock {return false}
    if lhs.serializeTx != rhs.serializeTx {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_SubscribeBlocksRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscribeBlocksRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "full_block"),
    2: .standard(proto: "full_transactions"),
    3: .standard(proto: "serialize_block"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.fullBlock) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.fullTransactions) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.serializeBlock) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.fullBlock != false {
      try visitor.visitSingularBoolField(value: self.fullBlock, fieldNumber: 1)
    }
    if self.fullTransactions != false {
      try visitor.visitSingularBoolField(value: self.fullTransactions, fieldNumber: 2)
    }
    if self.serializeBlock != false {
      try visitor.visitSingularBoolField(value: self.serializeBlock, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_SubscribeBlocksRequest, rhs: Pb_SubscribeBlocksRequest) -> Bool {
    if lhs.fullBlock != rhs.fullBlock {return false}
    if lhs.fullTransactions != rhs.fullTransactions {return false}
    if lhs.serializeBlock != rhs.serializeBlock {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_GetSlpTokenMetadataRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetSlpTokenMetadataRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "token_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBytesField(value: &self.tokenIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tokenIds.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.tokenIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_GetSlpTokenMetadataRequest, rhs: Pb_GetSlpTokenMetadataRequest) -> Bool {
    if lhs.tokenIds != rhs.tokenIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_GetSlpTokenMetadataResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetSlpTokenMetadataResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "token_metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.tokenMetadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tokenMetadata.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tokenMetadata, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_GetSlpTokenMetadataResponse, rhs: Pb_GetSlpTokenMetadataResponse) -> Bool {
    if lhs.tokenMetadata != rhs.tokenMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_GetSlpParsedScriptRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetSlpParsedScriptRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "slp_opreturn_script"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.slpOpreturnScript) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.slpOpreturnScript.isEmpty {
      try visitor.visitSingularBytesField(value: self.slpOpreturnScript, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_GetSlpParsedScriptRequest, rhs: Pb_GetSlpParsedScriptRequest) -> Bool {
    if lhs.slpOpreturnScript != rhs.slpOpreturnScript {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_GetSlpParsedScriptResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetSlpParsedScriptResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "parsing_error"),
    2: .standard(proto: "token_id"),
    3: .standard(proto: "slp_action"),
    4: .standard(proto: "token_type"),
    5: .standard(proto: "v1_genesis"),
    6: .standard(proto: "v1_mint"),
    7: .standard(proto: "v1_send"),
    8: .standard(proto: "v1_nft1_child_genesis"),
    9: .standard(proto: "v1_nft1_child_send"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parsingError) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.tokenID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.slpAction) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.tokenType) }()
      case 5: try {
        var v: Pb_SlpV1GenesisMetadata?
        var hadOneofValue = false
        if let current = self.slpMetadata {
          hadOneofValue = true
          if case .v1Genesis(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.slpMetadata = .v1Genesis(v)
        }
      }()
      case 6: try {
        var v: Pb_SlpV1MintMetadata?
        var hadOneofValue = false
        if let current = self.slpMetadata {
          hadOneofValue = true
          if case .v1Mint(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.slpMetadata = .v1Mint(v)
        }
      }()
      case 7: try {
        var v: Pb_SlpV1SendMetadata?
        var hadOneofValue = false
        if let current = self.slpMetadata {
          hadOneofValue = true
          if case .v1Send(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.slpMetadata = .v1Send(v)
        }
      }()
      case 8: try {
        var v: Pb_SlpV1Nft1ChildGenesisMetadata?
        var hadOneofValue = false
        if let current = self.slpMetadata {
          hadOneofValue = true
          if case .v1Nft1ChildGenesis(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.slpMetadata = .v1Nft1ChildGenesis(v)
        }
      }()
      case 9: try {
        var v: Pb_SlpV1Nft1ChildSendMetadata?
        var hadOneofValue = false
        if let current = self.slpMetadata {
          hadOneofValue = true
          if case .v1Nft1ChildSend(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.slpMetadata = .v1Nft1ChildSend(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parsingError.isEmpty {
      try visitor.visitSingularStringField(value: self.parsingError, fieldNumber: 1)
    }
    if !self.tokenID.isEmpty {
      try visitor.visitSingularBytesField(value: self.tokenID, fieldNumber: 2)
    }
    if self.slpAction != .nonSlp {
      try visitor.visitSingularEnumField(value: self.slpAction, fieldNumber: 3)
    }
    if self.tokenType != .versionNotSet {
      try visitor.visitSingularEnumField(value: self.tokenType, fieldNumber: 4)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.slpMetadata {
    case .v1Genesis?: try {
      guard case .v1Genesis(let v)? = self.slpMetadata else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .v1Mint?: try {
      guard case .v1Mint(let v)? = self.slpMetadata else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .v1Send?: try {
      guard case .v1Send(let v)? = self.slpMetadata else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .v1Nft1ChildGenesis?: try {
      guard case .v1Nft1ChildGenesis(let v)? = self.slpMetadata else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .v1Nft1ChildSend?: try {
      guard case .v1Nft1ChildSend(let v)? = self.slpMetadata else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_GetSlpParsedScriptResponse, rhs: Pb_GetSlpParsedScriptResponse) -> Bool {
    if lhs.parsingError != rhs.parsingError {return false}
    if lhs.tokenID != rhs.tokenID {return false}
    if lhs.slpAction != rhs.slpAction {return false}
    if lhs.tokenType != rhs.tokenType {return false}
    if lhs.slpMetadata != rhs.slpMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_GetSlpTrustedValidationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetSlpTrustedValidationRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "queries"),
    2: .standard(proto: "include_graphsearch_count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.queries) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.includeGraphsearchCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.queries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.queries, fieldNumber: 1)
    }
    if self.includeGraphsearchCount != false {
      try visitor.visitSingularBoolField(value: self.includeGraphsearchCount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_GetSlpTrustedValidationRequest, rhs: Pb_GetSlpTrustedValidationRequest) -> Bool {
    if lhs.queries != rhs.queries {return false}
    if lhs.includeGraphsearchCount != rhs.includeGraphsearchCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_GetSlpTrustedValidationRequest.Query: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Pb_GetSlpTrustedValidationRequest.protoMessageName + ".Query"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "prev_out_hash"),
    2: .standard(proto: "prev_out_vout"),
    3: .standard(proto: "graphsearch_valid_hashes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.prevOutHash) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.prevOutVout) }()
      case 3: try { try decoder.decodeRepeatedBytesField(value: &self.graphsearchValidHashes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.prevOutHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.prevOutHash, fieldNumber: 1)
    }
    if self.prevOutVout != 0 {
      try visitor.visitSingularUInt32Field(value: self.prevOutVout, fieldNumber: 2)
    }
    if !self.graphsearchValidHashes.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.graphsearchValidHashes, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_GetSlpTrustedValidationRequest.Query, rhs: Pb_GetSlpTrustedValidationRequest.Query) -> Bool {
    if lhs.prevOutHash != rhs.prevOutHash {return false}
    if lhs.prevOutVout != rhs.prevOutVout {return false}
    if lhs.graphsearchValidHashes != rhs.graphsearchValidHashes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_GetSlpTrustedValidationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetSlpTrustedValidationResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "results"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.results) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.results.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.results, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_GetSlpTrustedValidationResponse, rhs: Pb_GetSlpTrustedValidationResponse) -> Bool {
    if lhs.results != rhs.results {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_GetSlpTrustedValidationResponse.ValidityResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Pb_GetSlpTrustedValidationResponse.protoMessageName + ".ValidityResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "prev_out_hash"),
    2: .standard(proto: "prev_out_vout"),
    3: .standard(proto: "token_id"),
    4: .standard(proto: "slp_action"),
    5: .standard(proto: "token_type"),
    6: .standard(proto: "v1_token_amount"),
    7: .standard(proto: "v1_mint_baton"),
    8: .standard(proto: "slp_txn_opreturn"),
    9: .standard(proto: "graphsearch_txn_count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.prevOutHash) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.prevOutVout) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.tokenID) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.slpAction) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.tokenType) }()
      case 6: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.validityResultType != nil {try decoder.handleConflictingOneOf()}
          self.validityResultType = .v1TokenAmount(v)
        }
      }()
      case 7: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.validityResultType != nil {try decoder.handleConflictingOneOf()}
          self.validityResultType = .v1MintBaton(v)
        }
      }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self.slpTxnOpreturn) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self.graphsearchTxnCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.prevOutHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.prevOutHash, fieldNumber: 1)
    }
    if self.prevOutVout != 0 {
      try visitor.visitSingularUInt32Field(value: self.prevOutVout, fieldNumber: 2)
    }
    if !self.tokenID.isEmpty {
      try visitor.visitSingularBytesField(value: self.tokenID, fieldNumber: 3)
    }
    if self.slpAction != .nonSlp {
      try visitor.visitSingularEnumField(value: self.slpAction, fieldNumber: 4)
    }
    if self.tokenType != .versionNotSet {
      try visitor.visitSingularEnumField(value: self.tokenType, fieldNumber: 5)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.validityResultType {
    case .v1TokenAmount?: try {
      guard case .v1TokenAmount(let v)? = self.validityResultType else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 6)
    }()
    case .v1MintBaton?: try {
      guard case .v1MintBaton(let v)? = self.validityResultType else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    if !self.slpTxnOpreturn.isEmpty {
      try visitor.visitSingularBytesField(value: self.slpTxnOpreturn, fieldNumber: 8)
    }
    if self.graphsearchTxnCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.graphsearchTxnCount, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_GetSlpTrustedValidationResponse.ValidityResult, rhs: Pb_GetSlpTrustedValidationResponse.ValidityResult) -> Bool {
    if lhs.prevOutHash != rhs.prevOutHash {return false}
    if lhs.prevOutVout != rhs.prevOutVout {return false}
    if lhs.tokenID != rhs.tokenID {return false}
    if lhs.slpAction != rhs.slpAction {return false}
    if lhs.tokenType != rhs.tokenType {return false}
    if lhs.validityResultType != rhs.validityResultType {return false}
    if lhs.slpTxnOpreturn != rhs.slpTxnOpreturn {return false}
    if lhs.graphsearchTxnCount != rhs.graphsearchTxnCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_GetSlpGraphSearchRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetSlpGraphSearchRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .standard(proto: "valid_hashes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.hash) }()
      case 2: try { try decoder.decodeRepeatedBytesField(value: &self.validHashes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 1)
    }
    if !self.validHashes.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.validHashes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_GetSlpGraphSearchRequest, rhs: Pb_GetSlpGraphSearchRequest) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.validHashes != rhs.validHashes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_GetSlpGraphSearchResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetSlpGraphSearchResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "txdata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBytesField(value: &self.txdata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txdata.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.txdata, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_GetSlpGraphSearchResponse, rhs: Pb_GetSlpGraphSearchResponse) -> Bool {
    if lhs.txdata != rhs.txdata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_BlockNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BlockNotification"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "block_info"),
    3: .standard(proto: "marshaled_block"),
    4: .standard(proto: "serialized_block"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try {
        var v: Pb_BlockInfo?
        var hadOneofValue = false
        if let current = self.block {
          hadOneofValue = true
          if case .blockInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.block = .blockInfo(v)
        }
      }()
      case 3: try {
        var v: Pb_Block?
        var hadOneofValue = false
        if let current = self.block {
          hadOneofValue = true
          if case .marshaledBlock(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.block = .marshaledBlock(v)
        }
      }()
      case 4: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.block != nil {try decoder.handleConflictingOneOf()}
          self.block = .serializedBlock(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .connected {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.block {
    case .blockInfo?: try {
      guard case .blockInfo(let v)? = self.block else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .marshaledBlock?: try {
      guard case .marshaledBlock(let v)? = self.block else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .serializedBlock?: try {
      guard case .serializedBlock(let v)? = self.block else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_BlockNotification, rhs: Pb_BlockNotification) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.block != rhs.block {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_BlockNotification.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CONNECTED"),
    1: .same(proto: "DISCONNECTED"),
  ]
}

extension Pb_TransactionNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransactionNotification"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "confirmed_transaction"),
    3: .standard(proto: "unconfirmed_transaction"),
    4: .standard(proto: "serialized_transaction"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try {
        var v: Pb_Transaction?
        var hadOneofValue = false
        if let current = self.transaction {
          hadOneofValue = true
          if case .confirmedTransaction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.transaction = .confirmedTransaction(v)
        }
      }()
      case 3: try {
        var v: Pb_MempoolTransaction?
        var hadOneofValue = false
        if let current = self.transaction {
          hadOneofValue = true
          if case .unconfirmedTransaction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.transaction = .unconfirmedTransaction(v)
        }
      }()
      case 4: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.transaction != nil {try decoder.handleConflictingOneOf()}
          self.transaction = .serializedTransaction(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .unconfirmed {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.transaction {
    case .confirmedTransaction?: try {
      guard case .confirmedTransaction(let v)? = self.transaction else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .unconfirmedTransaction?: try {
      guard case .unconfirmedTransaction(let v)? = self.transaction else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .serializedTransaction?: try {
      guard case .serializedTransaction(let v)? = self.transaction else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_TransactionNotification, rhs: Pb_TransactionNotification) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.transaction != rhs.transaction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_TransactionNotification.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNCONFIRMED"),
    1: .same(proto: "CONFIRMED"),
  ]
}

extension Pb_BlockInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BlockInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "height"),
    3: .same(proto: "version"),
    4: .standard(proto: "previous_block"),
    5: .standard(proto: "merkle_root"),
    6: .same(proto: "timestamp"),
    7: .same(proto: "bits"),
    8: .same(proto: "nonce"),
    9: .same(proto: "confirmations"),
    10: .same(proto: "difficulty"),
    11: .standard(proto: "next_block_hash"),
    12: .same(proto: "size"),
    13: .standard(proto: "median_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.hash) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.height) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.version) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.previousBlock) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.merkleRoot) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.bits) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.nonce) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.confirmations) }()
      case 10: try { try decoder.decodeSingularDoubleField(value: &self.difficulty) }()
      case 11: try { try decoder.decodeSingularBytesField(value: &self.nextBlockHash) }()
      case 12: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      case 13: try { try decoder.decodeSingularInt64Field(value: &self.medianTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularInt32Field(value: self.height, fieldNumber: 2)
    }
    if self.version != 0 {
      try visitor.visitSingularInt32Field(value: self.version, fieldNumber: 3)
    }
    if !self.previousBlock.isEmpty {
      try visitor.visitSingularBytesField(value: self.previousBlock, fieldNumber: 4)
    }
    if !self.merkleRoot.isEmpty {
      try visitor.visitSingularBytesField(value: self.merkleRoot, fieldNumber: 5)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 6)
    }
    if self.bits != 0 {
      try visitor.visitSingularUInt32Field(value: self.bits, fieldNumber: 7)
    }
    if self.nonce != 0 {
      try visitor.visitSingularUInt32Field(value: self.nonce, fieldNumber: 8)
    }
    if self.confirmations != 0 {
      try visitor.visitSingularInt32Field(value: self.confirmations, fieldNumber: 9)
    }
    if self.difficulty != 0 {
      try visitor.visitSingularDoubleField(value: self.difficulty, fieldNumber: 10)
    }
    if !self.nextBlockHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextBlockHash, fieldNumber: 11)
    }
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 12)
    }
    if self.medianTime != 0 {
      try visitor.visitSingularInt64Field(value: self.medianTime, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_BlockInfo, rhs: Pb_BlockInfo) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.height != rhs.height {return false}
    if lhs.version != rhs.version {return false}
    if lhs.previousBlock != rhs.previousBlock {return false}
    if lhs.merkleRoot != rhs.merkleRoot {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.bits != rhs.bits {return false}
    if lhs.nonce != rhs.nonce {return false}
    if lhs.confirmations != rhs.confirmations {return false}
    if lhs.difficulty != rhs.difficulty {return false}
    if lhs.nextBlockHash != rhs.nextBlockHash {return false}
    if lhs.size != rhs.size {return false}
    if lhs.medianTime != rhs.medianTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_Block: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Block"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "info"),
    2: .standard(proto: "transaction_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.transactionData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.transactionData.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.transactionData, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_Block, rhs: Pb_Block) -> Bool {
    if lhs._info != rhs._info {return false}
    if lhs.transactionData != rhs.transactionData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_Block.TransactionData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Pb_Block.protoMessageName + ".TransactionData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transaction_hash"),
    2: .same(proto: "transaction"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.txidsOrTxs != nil {try decoder.handleConflictingOneOf()}
          self.txidsOrTxs = .transactionHash(v)
        }
      }()
      case 2: try {
        var v: Pb_Transaction?
        var hadOneofValue = false
        if let current = self.txidsOrTxs {
          hadOneofValue = true
          if case .transaction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.txidsOrTxs = .transaction(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.txidsOrTxs {
    case .transactionHash?: try {
      guard case .transactionHash(let v)? = self.txidsOrTxs else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }()
    case .transaction?: try {
      guard case .transaction(let v)? = self.txidsOrTxs else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_Block.TransactionData, rhs: Pb_Block.TransactionData) -> Bool {
    if lhs.txidsOrTxs != rhs.txidsOrTxs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_Transaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Transaction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "version"),
    3: .same(proto: "inputs"),
    4: .same(proto: "outputs"),
    5: .standard(proto: "lock_time"),
    8: .same(proto: "size"),
    9: .same(proto: "timestamp"),
    10: .same(proto: "confirmations"),
    11: .standard(proto: "block_height"),
    12: .standard(proto: "block_hash"),
    13: .standard(proto: "slp_transaction_info"),
  ]

  fileprivate class _StorageClass {
    var _hash: Data = Data()
    var _version: Int32 = 0
    var _inputs: [Pb_Transaction.Input] = []
    var _outputs: [Pb_Transaction.Output] = []
    var _lockTime: UInt32 = 0
    var _size: Int32 = 0
    var _timestamp: Int64 = 0
    var _confirmations: Int32 = 0
    var _blockHeight: Int32 = 0
    var _blockHash: Data = Data()
    var _slpTransactionInfo: Pb_SlpTransactionInfo? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _hash = source._hash
      _version = source._version
      _inputs = source._inputs
      _outputs = source._outputs
      _lockTime = source._lockTime
      _size = source._size
      _timestamp = source._timestamp
      _confirmations = source._confirmations
      _blockHeight = source._blockHeight
      _blockHash = source._blockHash
      _slpTransactionInfo = source._slpTransactionInfo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBytesField(value: &_storage._hash) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._version) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._inputs) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._outputs) }()
        case 5: try { try decoder.decodeSingularUInt32Field(value: &_storage._lockTime) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._size) }()
        case 9: try { try decoder.decodeSingularInt64Field(value: &_storage._timestamp) }()
        case 10: try { try decoder.decodeSingularInt32Field(value: &_storage._confirmations) }()
        case 11: try { try decoder.decodeSingularInt32Field(value: &_storage._blockHeight) }()
        case 12: try { try decoder.decodeSingularBytesField(value: &_storage._blockHash) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._slpTransactionInfo) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._hash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._hash, fieldNumber: 1)
      }
      if _storage._version != 0 {
        try visitor.visitSingularInt32Field(value: _storage._version, fieldNumber: 2)
      }
      if !_storage._inputs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._inputs, fieldNumber: 3)
      }
      if !_storage._outputs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._outputs, fieldNumber: 4)
      }
      if _storage._lockTime != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._lockTime, fieldNumber: 5)
      }
      if _storage._size != 0 {
        try visitor.visitSingularInt32Field(value: _storage._size, fieldNumber: 8)
      }
      if _storage._timestamp != 0 {
        try visitor.visitSingularInt64Field(value: _storage._timestamp, fieldNumber: 9)
      }
      if _storage._confirmations != 0 {
        try visitor.visitSingularInt32Field(value: _storage._confirmations, fieldNumber: 10)
      }
      if _storage._blockHeight != 0 {
        try visitor.visitSingularInt32Field(value: _storage._blockHeight, fieldNumber: 11)
      }
      if !_storage._blockHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._blockHash, fieldNumber: 12)
      }
      if let v = _storage._slpTransactionInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_Transaction, rhs: Pb_Transaction) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._hash != rhs_storage._hash {return false}
        if _storage._version != rhs_storage._version {return false}
        if _storage._inputs != rhs_storage._inputs {return false}
        if _storage._outputs != rhs_storage._outputs {return false}
        if _storage._lockTime != rhs_storage._lockTime {return false}
        if _storage._size != rhs_storage._size {return false}
        if _storage._timestamp != rhs_storage._timestamp {return false}
        if _storage._confirmations != rhs_storage._confirmations {return false}
        if _storage._blockHeight != rhs_storage._blockHeight {return false}
        if _storage._blockHash != rhs_storage._blockHash {return false}
        if _storage._slpTransactionInfo != rhs_storage._slpTransactionInfo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_Transaction.Input: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Pb_Transaction.protoMessageName + ".Input"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
    2: .same(proto: "outpoint"),
    3: .standard(proto: "signature_script"),
    4: .same(proto: "sequence"),
    5: .same(proto: "value"),
    6: .standard(proto: "previous_script"),
    7: .same(proto: "address"),
    8: .standard(proto: "slp_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.index) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._outpoint) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.signatureScript) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.sequence) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.value) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.previousScript) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._slpToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.index != 0 {
      try visitor.visitSingularUInt32Field(value: self.index, fieldNumber: 1)
    }
    if let v = self._outpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.signatureScript.isEmpty {
      try visitor.visitSingularBytesField(value: self.signatureScript, fieldNumber: 3)
    }
    if self.sequence != 0 {
      try visitor.visitSingularUInt32Field(value: self.sequence, fieldNumber: 4)
    }
    if self.value != 0 {
      try visitor.visitSingularInt64Field(value: self.value, fieldNumber: 5)
    }
    if !self.previousScript.isEmpty {
      try visitor.visitSingularBytesField(value: self.previousScript, fieldNumber: 6)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 7)
    }
    if let v = self._slpToken {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_Transaction.Input, rhs: Pb_Transaction.Input) -> Bool {
    if lhs.index != rhs.index {return false}
    if lhs._outpoint != rhs._outpoint {return false}
    if lhs.signatureScript != rhs.signatureScript {return false}
    if lhs.sequence != rhs.sequence {return false}
    if lhs.value != rhs.value {return false}
    if lhs.previousScript != rhs.previousScript {return false}
    if lhs.address != rhs.address {return false}
    if lhs._slpToken != rhs._slpToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_Transaction.Input.Outpoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Pb_Transaction.Input.protoMessageName + ".Outpoint"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.hash) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.index) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 1)
    }
    if self.index != 0 {
      try visitor.visitSingularUInt32Field(value: self.index, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_Transaction.Input.Outpoint, rhs: Pb_Transaction.Input.Outpoint) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.index != rhs.index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_Transaction.Output: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Pb_Transaction.protoMessageName + ".Output"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
    2: .same(proto: "value"),
    3: .standard(proto: "pubkey_script"),
    4: .same(proto: "address"),
    5: .standard(proto: "script_class"),
    6: .standard(proto: "disassembled_script"),
    7: .standard(proto: "slp_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.index) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.value) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.pubkeyScript) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.scriptClass) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.disassembledScript) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._slpToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.index != 0 {
      try visitor.visitSingularUInt32Field(value: self.index, fieldNumber: 1)
    }
    if self.value != 0 {
      try visitor.visitSingularInt64Field(value: self.value, fieldNumber: 2)
    }
    if !self.pubkeyScript.isEmpty {
      try visitor.visitSingularBytesField(value: self.pubkeyScript, fieldNumber: 3)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 4)
    }
    if !self.scriptClass.isEmpty {
      try visitor.visitSingularStringField(value: self.scriptClass, fieldNumber: 5)
    }
    if !self.disassembledScript.isEmpty {
      try visitor.visitSingularStringField(value: self.disassembledScript, fieldNumber: 6)
    }
    if let v = self._slpToken {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_Transaction.Output, rhs: Pb_Transaction.Output) -> Bool {
    if lhs.index != rhs.index {return false}
    if lhs.value != rhs.value {return false}
    if lhs.pubkeyScript != rhs.pubkeyScript {return false}
    if lhs.address != rhs.address {return false}
    if lhs.scriptClass != rhs.scriptClass {return false}
    if lhs.disassembledScript != rhs.disassembledScript {return false}
    if lhs._slpToken != rhs._slpToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_MempoolTransaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MempoolTransaction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transaction"),
    2: .standard(proto: "added_time"),
    3: .standard(proto: "added_height"),
    4: .same(proto: "fee"),
    5: .standard(proto: "fee_per_kb"),
    6: .standard(proto: "starting_priority"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._transaction) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.addedTime) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.addedHeight) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.fee) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.feePerKb) }()
      case 6: try { try decoder.decodeSingularDoubleField(value: &self.startingPriority) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._transaction {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.addedTime != 0 {
      try visitor.visitSingularInt64Field(value: self.addedTime, fieldNumber: 2)
    }
    if self.addedHeight != 0 {
      try visitor.visitSingularInt32Field(value: self.addedHeight, fieldNumber: 3)
    }
    if self.fee != 0 {
      try visitor.visitSingularInt64Field(value: self.fee, fieldNumber: 4)
    }
    if self.feePerKb != 0 {
      try visitor.visitSingularInt64Field(value: self.feePerKb, fieldNumber: 5)
    }
    if self.startingPriority != 0 {
      try visitor.visitSingularDoubleField(value: self.startingPriority, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_MempoolTransaction, rhs: Pb_MempoolTransaction) -> Bool {
    if lhs._transaction != rhs._transaction {return false}
    if lhs.addedTime != rhs.addedTime {return false}
    if lhs.addedHeight != rhs.addedHeight {return false}
    if lhs.fee != rhs.fee {return false}
    if lhs.feePerKb != rhs.feePerKb {return false}
    if lhs.startingPriority != rhs.startingPriority {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_UnspentOutput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UnspentOutput"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "outpoint"),
    2: .standard(proto: "pubkey_script"),
    3: .same(proto: "value"),
    4: .standard(proto: "is_coinbase"),
    5: .standard(proto: "block_height"),
    6: .standard(proto: "slp_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._outpoint) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.pubkeyScript) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.value) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isCoinbase) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.blockHeight) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._slpToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._outpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.pubkeyScript.isEmpty {
      try visitor.visitSingularBytesField(value: self.pubkeyScript, fieldNumber: 2)
    }
    if self.value != 0 {
      try visitor.visitSingularInt64Field(value: self.value, fieldNumber: 3)
    }
    if self.isCoinbase != false {
      try visitor.visitSingularBoolField(value: self.isCoinbase, fieldNumber: 4)
    }
    if self.blockHeight != 0 {
      try visitor.visitSingularInt32Field(value: self.blockHeight, fieldNumber: 5)
    }
    if let v = self._slpToken {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_UnspentOutput, rhs: Pb_UnspentOutput) -> Bool {
    if lhs._outpoint != rhs._outpoint {return false}
    if lhs.pubkeyScript != rhs.pubkeyScript {return false}
    if lhs.value != rhs.value {return false}
    if lhs.isCoinbase != rhs.isCoinbase {return false}
    if lhs.blockHeight != rhs.blockHeight {return false}
    if lhs._slpToken != rhs._slpToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_TransactionFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransactionFilter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "addresses"),
    2: .same(proto: "outpoints"),
    3: .standard(proto: "data_elements"),
    4: .standard(proto: "all_transactions"),
    5: .standard(proto: "all_slp_transactions"),
    6: .standard(proto: "slp_token_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.addresses) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.outpoints) }()
      case 3: try { try decoder.decodeRepeatedBytesField(value: &self.dataElements) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.allTransactions) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.allSlpTransactions) }()
      case 6: try { try decoder.decodeRepeatedBytesField(value: &self.slpTokenIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.addresses.isEmpty {
      try visitor.visitRepeatedStringField(value: self.addresses, fieldNumber: 1)
    }
    if !self.outpoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.outpoints, fieldNumber: 2)
    }
    if !self.dataElements.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.dataElements, fieldNumber: 3)
    }
    if self.allTransactions != false {
      try visitor.visitSingularBoolField(value: self.allTransactions, fieldNumber: 4)
    }
    if self.allSlpTransactions != false {
      try visitor.visitSingularBoolField(value: self.allSlpTransactions, fieldNumber: 5)
    }
    if !self.slpTokenIds.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.slpTokenIds, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_TransactionFilter, rhs: Pb_TransactionFilter) -> Bool {
    if lhs.addresses != rhs.addresses {return false}
    if lhs.outpoints != rhs.outpoints {return false}
    if lhs.dataElements != rhs.dataElements {return false}
    if lhs.allTransactions != rhs.allTransactions {return false}
    if lhs.allSlpTransactions != rhs.allSlpTransactions {return false}
    if lhs.slpTokenIds != rhs.slpTokenIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_SlpToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SlpToken"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "token_id"),
    2: .same(proto: "amount"),
    3: .standard(proto: "is_mint_baton"),
    4: .same(proto: "address"),
    5: .same(proto: "decimals"),
    6: .standard(proto: "slp_action"),
    7: .standard(proto: "token_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.tokenID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.amount) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isMintBaton) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.decimals) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.slpAction) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.tokenType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tokenID.isEmpty {
      try visitor.visitSingularBytesField(value: self.tokenID, fieldNumber: 1)
    }
    if self.amount != 0 {
      try visitor.visitSingularUInt64Field(value: self.amount, fieldNumber: 2)
    }
    if self.isMintBaton != false {
      try visitor.visitSingularBoolField(value: self.isMintBaton, fieldNumber: 3)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 4)
    }
    if self.decimals != 0 {
      try visitor.visitSingularUInt32Field(value: self.decimals, fieldNumber: 5)
    }
    if self.slpAction != .nonSlp {
      try visitor.visitSingularEnumField(value: self.slpAction, fieldNumber: 6)
    }
    if self.tokenType != .versionNotSet {
      try visitor.visitSingularEnumField(value: self.tokenType, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_SlpToken, rhs: Pb_SlpToken) -> Bool {
    if lhs.tokenID != rhs.tokenID {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.isMintBaton != rhs.isMintBaton {return false}
    if lhs.address != rhs.address {return false}
    if lhs.decimals != rhs.decimals {return false}
    if lhs.slpAction != rhs.slpAction {return false}
    if lhs.tokenType != rhs.tokenType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_SlpTransactionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SlpTransactionInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "slp_action"),
    2: .standard(proto: "validity_judgement"),
    3: .standard(proto: "parse_error"),
    4: .standard(proto: "token_id"),
    5: .standard(proto: "burn_flags"),
    6: .standard(proto: "v1_genesis"),
    7: .standard(proto: "v1_mint"),
    8: .standard(proto: "v1_send"),
    9: .standard(proto: "v1_nft1_child_genesis"),
    10: .standard(proto: "v1_nft1_child_send"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.slpAction) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.validityJudgement) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.parseError) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.tokenID) }()
      case 5: try { try decoder.decodeRepeatedEnumField(value: &self.burnFlags) }()
      case 6: try {
        var v: Pb_SlpV1GenesisMetadata?
        var hadOneofValue = false
        if let current = self.txMetadata {
          hadOneofValue = true
          if case .v1Genesis(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.txMetadata = .v1Genesis(v)
        }
      }()
      case 7: try {
        var v: Pb_SlpV1MintMetadata?
        var hadOneofValue = false
        if let current = self.txMetadata {
          hadOneofValue = true
          if case .v1Mint(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.txMetadata = .v1Mint(v)
        }
      }()
      case 8: try {
        var v: Pb_SlpV1SendMetadata?
        var hadOneofValue = false
        if let current = self.txMetadata {
          hadOneofValue = true
          if case .v1Send(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.txMetadata = .v1Send(v)
        }
      }()
      case 9: try {
        var v: Pb_SlpV1Nft1ChildGenesisMetadata?
        var hadOneofValue = false
        if let current = self.txMetadata {
          hadOneofValue = true
          if case .v1Nft1ChildGenesis(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.txMetadata = .v1Nft1ChildGenesis(v)
        }
      }()
      case 10: try {
        var v: Pb_SlpV1Nft1ChildSendMetadata?
        var hadOneofValue = false
        if let current = self.txMetadata {
          hadOneofValue = true
          if case .v1Nft1ChildSend(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.txMetadata = .v1Nft1ChildSend(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.slpAction != .nonSlp {
      try visitor.visitSingularEnumField(value: self.slpAction, fieldNumber: 1)
    }
    if self.validityJudgement != .unknownOrInvalid {
      try visitor.visitSingularEnumField(value: self.validityJudgement, fieldNumber: 2)
    }
    if !self.parseError.isEmpty {
      try visitor.visitSingularStringField(value: self.parseError, fieldNumber: 3)
    }
    if !self.tokenID.isEmpty {
      try visitor.visitSingularBytesField(value: self.tokenID, fieldNumber: 4)
    }
    if !self.burnFlags.isEmpty {
      try visitor.visitPackedEnumField(value: self.burnFlags, fieldNumber: 5)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.txMetadata {
    case .v1Genesis?: try {
      guard case .v1Genesis(let v)? = self.txMetadata else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .v1Mint?: try {
      guard case .v1Mint(let v)? = self.txMetadata else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .v1Send?: try {
      guard case .v1Send(let v)? = self.txMetadata else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .v1Nft1ChildGenesis?: try {
      guard case .v1Nft1ChildGenesis(let v)? = self.txMetadata else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .v1Nft1ChildSend?: try {
      guard case .v1Nft1ChildSend(let v)? = self.txMetadata else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_SlpTransactionInfo, rhs: Pb_SlpTransactionInfo) -> Bool {
    if lhs.slpAction != rhs.slpAction {return false}
    if lhs.validityJudgement != rhs.validityJudgement {return false}
    if lhs.parseError != rhs.parseError {return false}
    if lhs.tokenID != rhs.tokenID {return false}
    if lhs.burnFlags != rhs.burnFlags {return false}
    if lhs.txMetadata != rhs.txMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_SlpTransactionInfo.ValidityJudgement: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_OR_INVALID"),
    1: .same(proto: "VALID"),
  ]
}

extension Pb_SlpTransactionInfo.BurnFlags: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BURNED_INPUTS_OUTPUTS_TOO_HIGH"),
    1: .same(proto: "BURNED_INPUTS_BAD_OPRETURN"),
    2: .same(proto: "BURNED_INPUTS_OTHER_TOKEN"),
    3: .same(proto: "BURNED_OUTPUTS_MISSING_BCH_VOUT"),
    4: .same(proto: "BURNED_INPUTS_GREATER_THAN_OUTPUTS"),
  ]
}

extension Pb_SlpV1GenesisMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SlpV1GenesisMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "ticker"),
    3: .standard(proto: "document_url"),
    4: .standard(proto: "document_hash"),
    5: .same(proto: "decimals"),
    6: .standard(proto: "mint_baton_vout"),
    7: .standard(proto: "mint_amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.ticker) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.documentURL) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.documentHash) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.decimals) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.mintBatonVout) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.mintAmount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularBytesField(value: self.name, fieldNumber: 1)
    }
    if !self.ticker.isEmpty {
      try visitor.visitSingularBytesField(value: self.ticker, fieldNumber: 2)
    }
    if !self.documentURL.isEmpty {
      try visitor.visitSingularBytesField(value: self.documentURL, fieldNumber: 3)
    }
    if !self.documentHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.documentHash, fieldNumber: 4)
    }
    if self.decimals != 0 {
      try visitor.visitSingularUInt32Field(value: self.decimals, fieldNumber: 5)
    }
    if self.mintBatonVout != 0 {
      try visitor.visitSingularUInt32Field(value: self.mintBatonVout, fieldNumber: 6)
    }
    if self.mintAmount != 0 {
      try visitor.visitSingularUInt64Field(value: self.mintAmount, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_SlpV1GenesisMetadata, rhs: Pb_SlpV1GenesisMetadata) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.ticker != rhs.ticker {return false}
    if lhs.documentURL != rhs.documentURL {return false}
    if lhs.documentHash != rhs.documentHash {return false}
    if lhs.decimals != rhs.decimals {return false}
    if lhs.mintBatonVout != rhs.mintBatonVout {return false}
    if lhs.mintAmount != rhs.mintAmount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_SlpV1MintMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SlpV1MintMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "mint_baton_vout"),
    2: .standard(proto: "mint_amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.mintBatonVout) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.mintAmount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.mintBatonVout != 0 {
      try visitor.visitSingularUInt32Field(value: self.mintBatonVout, fieldNumber: 1)
    }
    if self.mintAmount != 0 {
      try visitor.visitSingularUInt64Field(value: self.mintAmount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_SlpV1MintMetadata, rhs: Pb_SlpV1MintMetadata) -> Bool {
    if lhs.mintBatonVout != rhs.mintBatonVout {return false}
    if lhs.mintAmount != rhs.mintAmount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_SlpV1SendMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SlpV1SendMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "amounts"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt64Field(value: &self.amounts) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.amounts.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.amounts, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_SlpV1SendMetadata, rhs: Pb_SlpV1SendMetadata) -> Bool {
    if lhs.amounts != rhs.amounts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_SlpV1Nft1ChildGenesisMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SlpV1Nft1ChildGenesisMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "ticker"),
    3: .standard(proto: "document_url"),
    4: .standard(proto: "document_hash"),
    5: .same(proto: "decimals"),
    6: .standard(proto: "group_token_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.ticker) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.documentURL) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.documentHash) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.decimals) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.groupTokenID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularBytesField(value: self.name, fieldNumber: 1)
    }
    if !self.ticker.isEmpty {
      try visitor.visitSingularBytesField(value: self.ticker, fieldNumber: 2)
    }
    if !self.documentURL.isEmpty {
      try visitor.visitSingularBytesField(value: self.documentURL, fieldNumber: 3)
    }
    if !self.documentHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.documentHash, fieldNumber: 4)
    }
    if self.decimals != 0 {
      try visitor.visitSingularUInt32Field(value: self.decimals, fieldNumber: 5)
    }
    if !self.groupTokenID.isEmpty {
      try visitor.visitSingularBytesField(value: self.groupTokenID, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_SlpV1Nft1ChildGenesisMetadata, rhs: Pb_SlpV1Nft1ChildGenesisMetadata) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.ticker != rhs.ticker {return false}
    if lhs.documentURL != rhs.documentURL {return false}
    if lhs.documentHash != rhs.documentHash {return false}
    if lhs.decimals != rhs.decimals {return false}
    if lhs.groupTokenID != rhs.groupTokenID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_SlpV1Nft1ChildSendMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SlpV1Nft1ChildSendMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_token_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.groupTokenID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupTokenID.isEmpty {
      try visitor.visitSingularBytesField(value: self.groupTokenID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_SlpV1Nft1ChildSendMetadata, rhs: Pb_SlpV1Nft1ChildSendMetadata) -> Bool {
    if lhs.groupTokenID != rhs.groupTokenID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_SlpTokenMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SlpTokenMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "token_id"),
    2: .standard(proto: "token_type"),
    3: .standard(proto: "v1_fungible"),
    4: .standard(proto: "v1_nft1_group"),
    5: .standard(proto: "v1_nft1_child"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.tokenID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.tokenType) }()
      case 3: try {
        var v: Pb_SlpTokenMetadata.V1Fungible?
        var hadOneofValue = false
        if let current = self.typeMetadata {
          hadOneofValue = true
          if case .v1Fungible(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.typeMetadata = .v1Fungible(v)
        }
      }()
      case 4: try {
        var v: Pb_SlpTokenMetadata.V1NFT1Group?
        var hadOneofValue = false
        if let current = self.typeMetadata {
          hadOneofValue = true
          if case .v1Nft1Group(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.typeMetadata = .v1Nft1Group(v)
        }
      }()
      case 5: try {
        var v: Pb_SlpTokenMetadata.V1NFT1Child?
        var hadOneofValue = false
        if let current = self.typeMetadata {
          hadOneofValue = true
          if case .v1Nft1Child(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.typeMetadata = .v1Nft1Child(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tokenID.isEmpty {
      try visitor.visitSingularBytesField(value: self.tokenID, fieldNumber: 1)
    }
    if self.tokenType != .versionNotSet {
      try visitor.visitSingularEnumField(value: self.tokenType, fieldNumber: 2)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.typeMetadata {
    case .v1Fungible?: try {
      guard case .v1Fungible(let v)? = self.typeMetadata else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .v1Nft1Group?: try {
      guard case .v1Nft1Group(let v)? = self.typeMetadata else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .v1Nft1Child?: try {
      guard case .v1Nft1Child(let v)? = self.typeMetadata else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_SlpTokenMetadata, rhs: Pb_SlpTokenMetadata) -> Bool {
    if lhs.tokenID != rhs.tokenID {return false}
    if lhs.tokenType != rhs.tokenType {return false}
    if lhs.typeMetadata != rhs.typeMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_SlpTokenMetadata.V1Fungible: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Pb_SlpTokenMetadata.protoMessageName + ".V1Fungible"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "token_ticker"),
    2: .standard(proto: "token_name"),
    3: .standard(proto: "token_document_url"),
    4: .standard(proto: "token_document_hash"),
    5: .same(proto: "decimals"),
    6: .standard(proto: "mint_baton_hash"),
    7: .standard(proto: "mint_baton_vout"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tokenTicker) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.tokenName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.tokenDocumentURL) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.tokenDocumentHash) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.decimals) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.mintBatonHash) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.mintBatonVout) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tokenTicker.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenTicker, fieldNumber: 1)
    }
    if !self.tokenName.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenName, fieldNumber: 2)
    }
    if !self.tokenDocumentURL.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenDocumentURL, fieldNumber: 3)
    }
    if !self.tokenDocumentHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.tokenDocumentHash, fieldNumber: 4)
    }
    if self.decimals != 0 {
      try visitor.visitSingularUInt32Field(value: self.decimals, fieldNumber: 5)
    }
    if !self.mintBatonHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.mintBatonHash, fieldNumber: 6)
    }
    if self.mintBatonVout != 0 {
      try visitor.visitSingularUInt32Field(value: self.mintBatonVout, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_SlpTokenMetadata.V1Fungible, rhs: Pb_SlpTokenMetadata.V1Fungible) -> Bool {
    if lhs.tokenTicker != rhs.tokenTicker {return false}
    if lhs.tokenName != rhs.tokenName {return false}
    if lhs.tokenDocumentURL != rhs.tokenDocumentURL {return false}
    if lhs.tokenDocumentHash != rhs.tokenDocumentHash {return false}
    if lhs.decimals != rhs.decimals {return false}
    if lhs.mintBatonHash != rhs.mintBatonHash {return false}
    if lhs.mintBatonVout != rhs.mintBatonVout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_SlpTokenMetadata.V1NFT1Group: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Pb_SlpTokenMetadata.protoMessageName + ".V1NFT1Group"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "token_ticker"),
    2: .standard(proto: "token_name"),
    3: .standard(proto: "token_document_url"),
    4: .standard(proto: "token_document_hash"),
    5: .same(proto: "decimals"),
    6: .standard(proto: "mint_baton_hash"),
    7: .standard(proto: "mint_baton_vout"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tokenTicker) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.tokenName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.tokenDocumentURL) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.tokenDocumentHash) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.decimals) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.mintBatonHash) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.mintBatonVout) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tokenTicker.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenTicker, fieldNumber: 1)
    }
    if !self.tokenName.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenName, fieldNumber: 2)
    }
    if !self.tokenDocumentURL.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenDocumentURL, fieldNumber: 3)
    }
    if !self.tokenDocumentHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.tokenDocumentHash, fieldNumber: 4)
    }
    if self.decimals != 0 {
      try visitor.visitSingularUInt32Field(value: self.decimals, fieldNumber: 5)
    }
    if !self.mintBatonHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.mintBatonHash, fieldNumber: 6)
    }
    if self.mintBatonVout != 0 {
      try visitor.visitSingularUInt32Field(value: self.mintBatonVout, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_SlpTokenMetadata.V1NFT1Group, rhs: Pb_SlpTokenMetadata.V1NFT1Group) -> Bool {
    if lhs.tokenTicker != rhs.tokenTicker {return false}
    if lhs.tokenName != rhs.tokenName {return false}
    if lhs.tokenDocumentURL != rhs.tokenDocumentURL {return false}
    if lhs.tokenDocumentHash != rhs.tokenDocumentHash {return false}
    if lhs.decimals != rhs.decimals {return false}
    if lhs.mintBatonHash != rhs.mintBatonHash {return false}
    if lhs.mintBatonVout != rhs.mintBatonVout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_SlpTokenMetadata.V1NFT1Child: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Pb_SlpTokenMetadata.protoMessageName + ".V1NFT1Child"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "token_ticker"),
    2: .standard(proto: "token_name"),
    3: .standard(proto: "token_document_url"),
    4: .standard(proto: "token_document_hash"),
    5: .standard(proto: "group_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tokenTicker) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.tokenName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.tokenDocumentURL) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.tokenDocumentHash) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.groupID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tokenTicker.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenTicker, fieldNumber: 1)
    }
    if !self.tokenName.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenName, fieldNumber: 2)
    }
    if !self.tokenDocumentURL.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenDocumentURL, fieldNumber: 3)
    }
    if !self.tokenDocumentHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.tokenDocumentHash, fieldNumber: 4)
    }
    if !self.groupID.isEmpty {
      try visitor.visitSingularBytesField(value: self.groupID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_SlpTokenMetadata.V1NFT1Child, rhs: Pb_SlpTokenMetadata.V1NFT1Child) -> Bool {
    if lhs.tokenTicker != rhs.tokenTicker {return false}
    if lhs.tokenName != rhs.tokenName {return false}
    if lhs.tokenDocumentURL != rhs.tokenDocumentURL {return false}
    if lhs.tokenDocumentHash != rhs.tokenDocumentHash {return false}
    if lhs.groupID != rhs.groupID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_SlpRequiredBurn: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SlpRequiredBurn"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "outpoint"),
    2: .standard(proto: "token_id"),
    3: .standard(proto: "token_type"),
    4: .same(proto: "amount"),
    5: .standard(proto: "mint_baton_vout"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._outpoint) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.tokenID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.tokenType) }()
      case 4: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.burnIntention != nil {try decoder.handleConflictingOneOf()}
          self.burnIntention = .amount(v)
        }
      }()
      case 5: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.burnIntention != nil {try decoder.handleConflictingOneOf()}
          self.burnIntention = .mintBatonVout(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._outpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.tokenID.isEmpty {
      try visitor.visitSingularBytesField(value: self.tokenID, fieldNumber: 2)
    }
    if self.tokenType != .versionNotSet {
      try visitor.visitSingularEnumField(value: self.tokenType, fieldNumber: 3)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.burnIntention {
    case .amount?: try {
      guard case .amount(let v)? = self.burnIntention else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    }()
    case .mintBatonVout?: try {
      guard case .mintBatonVout(let v)? = self.burnIntention else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_SlpRequiredBurn, rhs: Pb_SlpRequiredBurn) -> Bool {
    if lhs._outpoint != rhs._outpoint {return false}
    if lhs.tokenID != rhs.tokenID {return false}
    if lhs.tokenType != rhs.tokenType {return false}
    if lhs.burnIntention != rhs.burnIntention {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
